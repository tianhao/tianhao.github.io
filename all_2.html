<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <title>
        
        #(coding X)
        
    </title>

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="atom.xml" rel="alternate" title="#(coding X)" type="application/atom+xml">

    <link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script src="asset/javascripts/jquery.min.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>

    <!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
    <!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
    <style type="text/css">
        /* latin */
        @font-face {
            font-family: 'Nunito';
            font-style: normal;
            font-weight: 300;
            src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
            unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
        }
        /* latin */
        @font-face {
            font-family: 'Nunito';
            font-style: normal;
            font-weight: 400;
            src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
            unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
        }
        /* latin */
        @font-face {
            font-family: 'Nunito';
            font-style: normal;
            font-weight: 700;
            src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
            unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
        }
    </style>

    <style type="text/css">
        .container .left-col{ opacity: 1;}
        #pagenavi a{ font-size: 1.3em;}
        #pagenavi .next:before{ top: 3px;}
        #pagenavi .prev:before{ top: 3px;}
        .container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
        .container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
        #header .subtitle {
            line-height: 1.2em;
            padding-top: 8px;
        }
        article pre{ background: none; border: none; padding: 0;}
        article .entry-content{text-align: left;}
        .share-comment{ padding: 25px 0px; clear: both;}
        hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
    </style>

</head>

<body>
<div class="container">
    <div class="left-col">
        <div class="intrude-less">
            <header id="header" class="inner">
                
                <div class="profilepic">
                    <img src="asset/icon.png" style="width:160px;">
                </div>
                

                <h1><a href="index.html">#(coding X)</a></h1>
                <p class="subtitle">写代码，折腾各种好玩的东西！</p>
                <nav id="main-nav">
                    <ul class="main">
                        
                        <li id=""><a target="_self" href="index.html">Home</a></li>
                        
                        <li id=""><a target="_self" href="archives.html">Archives</a></li>
                        
                    </ul>
                </nav>

                <nav id="sub-nav">
                    <div class="social">

                        
                        
                        
                        
                        
                        
                        
                        <a target="_blank" class="weibo" href="




http://weibo.com/liemi" title="weibo">Weibo</a>
                        <a target="_blank" class="twitter" target="_blank" href="https://twitter.com/tianhaox_com" title="Twitter">Twitter</a>
                        <a target="_blank" class="github" target="_blank" href="https://github.com/tianhao" title="GitHub">GitHub</a>
                        

                        <a class="rss" href="atom.xml" title="RSS">RSS</a>

                    </div>
                </nav>
                <br>
                <div id="site-categories" class="side-item ">
                    <div class="side-header">
                        <h2>Categories</h2>
                    </div>
                    <div class="side-content">
                        <p class="cat-list">
                            
                            <a href="Life.html"><strong>Life</strong></a>
                            
                            <a href="Spring.html"><strong>Spring</strong></a>
                            
                            <a href="Spring%20Boot.html"><strong>Spring Boot</strong></a>
                            
                        </p>
                    </div>
                </div>
								<br>
                <div id="site-categories" class="side-item">
                    <div class="side-header">
                        <h2>Recent Posts</h2>
                    </div>
                    <div class="side-content">
                        <ul class="posts-list">
                            
                            
                            <li class="post">
                                <a href="15057592893281.html">博客添加了gitment评论功能，要求 Github 登录</a>
                            </li>
                            
                            
                            
                            <li class="post">
                                <a href="14787505123542.html">SpringBoot 开发工具</a>
                            </li>
                            
                            
                            
                            <li class="post">
                                <a href="14786773151130.html">Spring Boot 发布</a>
                            </li>
                            
                            
                            
                            <li class="post">
                                <a href="14786335106268.html">Spring Boot 深入Actuator</a>
                            </li>
                            
                            
                            
                            <li class="post">
                                <a href="14785948397032.html">Spring Boot 自定义配置</a>
                            </li>
                            
                            
                            
                            <li class="post">
                                <a href="14785852868633.html">Spring Boot 开发第一个应用程序</a>
                            </li>
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                        </ul>
                    </div>
                </div>
            </header>
        </div> <!-- intrude-less -->
    </div> <!-- left-col -->

    <div class="mid-col">
        <div class="mid-col-container">
 <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-10-03T16:03:27+08:00" itemprop="datePublished">2016/10/3</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Spring.html'>Spring</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14754818073700.html" itemprop="url">
		Spring消息(1) JMS</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p><em>——《Spring实战》笔记 第17章</em></p>

<p>第 15 章讲的 RMI、Hessian、Burlap、HttpInvoker 是同步通信，而消息通信是异步通信。</p>

<p><strong>同步通信的限制</strong>：<br/>
1. <strong>同步通信意味着等待</strong>，客户端必须等待远程方法结束后才能继续执行，服务端的性能也会客户端的性能；<br/>
2. <strong>客户端通过服务接口与远程服务耦合</strong>，如果服务端接口有变化，客户端也要调整；<br/>
3. <strong>客户端与远程服务的位置耦合</strong>，客户端必须配置服务的网络位置，如果网络拓扑调整，客户端也要重新配置；<br/>
4. <strong>客户端与服务的可用性耦合</strong>，远程服务不可用，客户端也不可用。</p>

<p><strong>异步消息的优势</strong>：<br/>
1. <strong>无需等待</strong>，客户端不必等待消息被处理甚至是被投递，客户端只要把消息发送给消息代理；<br/>
2. <strong>面向消息和解耦</strong>，异步消息是以数据为中心的，客户端没有与特定的方法签名（JAVA 接口）绑定，任何可以处理数据队列或主题订阅者都可以处理由客户端发送的消息，而客户端不必了解远程服务的任何范畴；<br/>
3. <strong>位置独立</strong>，客户端和服务端无需知道对方是谁，对方的网络位置，他们只与消息中心通讯，客户端和服务端网络位置的改变不会影响另一端，除非消息中心网络位置调整了；<br/>
4. <strong>确保投递</strong>，消息被存储在消息中心，即使服务端不可用了消息也不会丢失，在服务端回复后可以继续处理消息；</p>

<h2 id="toc_0">安装并启动 ActiveMQ 服务</h2>

<p>Mac OS</p>

<pre><code>brew install apache-activemq # 安装
activemq start  # 启动
netstat -an | grep 61616 # 查看端口是否监听
</code></pre>

<p>在浏览器管理消息：<a href="http://localhost:8161/admin">http://localhost:8161/admin</a>   用户名/密码: admin/admin</p>

<h2 id="toc_1">配置</h2>

<h3 id="toc_2">配置消息中心连接工厂</h3>

<pre><code class="language-XML">&lt;!-- 使用默认 IP 和端口 --&gt;
&lt;bean id=&quot;connectionFactory&quot;
      class=&quot;org.apache.activemq.spring.ActiveMQConnectionFactory&quot; /&gt;
&lt;!-- or --&gt;
&lt;!-- 指定 IP 和端口 --&gt;
&lt;bean id=&quot;connectionFactory&quot;
      class=&quot;org.apache.activemq.spring.ActiveMQConnectionFactory&quot;
      p:brokerURL=&quot;tcp://localhost:61616&quot; /&gt;
&lt;!-- or --&gt;
&lt;!--  首先要声明空间：xmlns:amq=&quot;http://activemq.apache.org/schema/core&quot; --&gt;
&lt;amq:connectionFactory id=&quot;connectionFactory&quot; brokerURL=&quot;tcp://localhost:61616&quot;/&gt;
</code></pre>

<h3 id="toc_3">声明 ActiveMQ 消息目的地</h3>

<pre><code>&lt;!--队列类型--&gt;
&lt;bean id=&quot;spittleQueue&quot; class=&quot;org.apache.activemq.command.ActiveMQQueue&quot;
      c:_=&quot;spittle.alert.queue&quot; /&gt;
&lt;!-- or --&gt;
&lt;!--主题类型--&gt;
&lt;bean id=&quot;spittleTopic&quot; class=&quot;org.apache.activemq.command.ActiveMQTopic&quot;
      c:_=&quot;spittle.alert.topic&quot; /&gt;
&lt;!-- or --&gt;
&lt;!-- 队列类型 --&gt;
&lt;amq:queue id=&quot;spittleQueue&quot; physicalName=&quot;spittle.alert.queue&quot; /&gt;
&lt;!-- or --&gt;
&lt;!-- 主题类型 --&gt;
&lt;amq:topic id=&quot;spittleTopic&quot; physicalName=&quot;spittle.alert.topic&quot; /&gt;
</code></pre>

<h3 id="toc_4">配置 JMS 模板</h3>

<pre><code class="language-XML">&lt;!-- 最简配置 --&gt;
&lt;bean id=&quot;jmsTemplate&quot;
      class=&quot;org.springframework.jms.core.JmsTemplate&quot;
       c:_-ref=&quot;connectionFactory&quot; /&gt;
&lt;!-- or --&gt;       
&lt;!-- + 设置默认目的地 --&gt;
&lt;bean id=&quot;jmsTemplate&quot;
      class=&quot;org.springframework.jms.core.JmsTemplate&quot;
      c:_-ref=&quot;connectionFactory&quot;
      p:defaultDestination-ref=&quot;spittleQueue&quot;/&gt;
      
&lt;!-- or --&gt;

&lt;!-- + 设置消息转换器 --&gt;
&lt;bean id=&quot;messageConverter&quot; 
      class=&quot;org.springframework.jms.support.converter.MappingJackson2MessageConverter&quot; /&gt;
      
&lt;bean id=&quot;jmsTemplate&quot;
      class=&quot;org.springframework.jms.core.JmsTemplate&quot;
      c:_-ref=&quot;connectionFactory&quot;
      p:defaultDestinationName=&quot;spittle.alert.queue&quot;
      p:messageConverter-ref=&quot;messageConverter&quot; /&gt;      
</code></pre>

<h3 id="toc_5">配置消息监听器</h3>

<hr/>

<h2 id="toc_6">发送消息 send()</h2>

<p>JmsOperations 接口 send()方法有3个重载方法，JmsTemplate实现了JmsOperations接口</p>

<pre><code class="language-JAVA">    // 发送到默认目的地，要求配置默认目的地
    void send(MessageCreator messageCreator) throws JmsException;
    // 发送到指定目的地
    void send(Destination destination, MessageCreator messageCreator) throws JmsException;
    // 发送到指定目的地
    void send(String destinationName, MessageCreator messageCreator) throws JmsException;
</code></pre>

<p>通过上面的的接口可以看出，在发送消息时可选择发送到默认目的地或者指定目的地， 目的地可以通过应用或者名称指定，另外，这些方法都有MessageCreator类型的参数，这是一个接口，实现该接口的方法要实现将消息体对象转化为javax.jms.Message类型的对象。</p>

<p>示例：</p>

<pre><code class="language-发送到指定目的地">  public AlertServiceImpl(JmsOperations jmsOperations) {
    this.jmsOperations = jmsOperations;
  }

  // 发送到指定目的地
  public void sendSpittleAlert(final Spittle spittle) {
    jmsOperations.send(
      &quot;spittle.alert.queue&quot;,
      new MessageCreator() {
        public Message createMessage(Session session)
                       throws JMSException {
          return session.createObjectMessage(spittle);
        }
      }
    );
  }

  // 发送到默认目的地
  public void sendSpittleAlert2Defualt(final Spittle spittle) {
    jmsOperations.send(
      new MessageCreator() {
        public Message createMessage(Session session)
                       throws JMSException {
          return session.createObjectMessage(spittle);
        }
      }
    );
  }
</code></pre>

<hr/>

<h2 id="toc_7">发送消息时，对消息进行转换 convertAndSend()</h2>

<pre><code>    void convertAndSend(Object message) throws JmsException;
    void convertAndSend(Destination destination, Object message) throws JmsException;
    void convertAndSend(String destinationName, Object message) throws JmsException;
    void convertAndSend(Object message, MessagePostProcessor postProcessor)
        throws JmsException;
</code></pre>

<p>可选的消息转换器：</p>

<ol>
<li>MappingJacksonMessageConverter, Jackson JSON 库，JSON 格式转换，Spring 4有已废除；</li>
<li>MappingJacksonMessageConverter, Jackson 2 JSON库，JSON 格式转换；</li>
<li>MarshallingMessageConverter, JAXB库，XML 格式转换；</li>
<li>SimpleMessageConverter，默认转换器，转换String 与 TextMessage，Map 与 MapMessage（ByteMessage），Serializable 对象与 ObjectMessage。</li>
</ol>

<p>默认消息转换器是 SimpleMessageConverter，如果要使用其它转换器，可以设置默认转换器：</p>

<pre><code>&lt;!-- 消息转换器 --&gt;
&lt;bean id=&quot;messageConverter&quot;
          class=&quot;org.springframework.jms.support.converter.MappingJackson2MessageConverter&quot;&gt;
        &lt;property name=&quot;typeIdMappings&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;Spittle&quot; value=&quot;spittr.domain.Spittle&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name=&quot;typeIdPropertyName&quot; value=&quot;Spittle&quot;/&gt;
    &lt;/bean&gt;
      
&lt;bean id=&quot;jmsTemplate&quot;
      class=&quot;org.springframework.jms.core.JmsTemplate&quot;
      c:_-ref=&quot;connectionFactory&quot;
      p:defaultDestinationName=&quot;spittle.alert.queue&quot;
      p:messageConverter-ref=&quot;messageConverter&quot; /&gt;     
</code></pre>

<p>代码：</p>

<pre><code class="language-JAVA">    public void sendAndConvertSpittleAlert2Default(Spittle spittle) {
        jmsOperations.convertAndSend(spittle);
    }

    public void sendAndConvertSpittleAlert(Spittle spittle) {
        jmsOperations.convertAndSend(&quot;spittle.alert.queue&quot;,spittle);
    }
</code></pre>

<p>实验后发现 MappingJackson2MessageConverter 是个大坑， 必须配置typeIdPropertyName 和 typeIdMappings 否则无法转换，而且生产者和消费者都必须配置。<br/>
由于监听没有该配置项，所以监听不能用MappingJackson2MessageConverter。</p>

<h2 id="toc_8">接收消息 receive() 和 receiveAndConvert()</h2>

<p>接受消息有 receive() 和 receiveAndConvert() 2个方法，前者返回的是 ObjectMessage，ObjectMessage 有getObject()方法获取消息体，但是会抛出检查下型异常 JMSException，一般 用 <code>JmsUtils.convertJmsAccessException(e)</code>将异常转化为非检查型异常，后缀可以直接将消息转化为实体对象，且抛出的是非检查型异常。</p>

<pre><code class="language-JAVA">    public Spittle getSpittleAlert() {
        try {
            ObjectMessage message = (ObjectMessage) jmsOperations.receive();
            return (Spittle) message.getObject();
        } catch (JMSException e) {
            // 将 JMSException异常转换为未检查行异常 JmsException
            throw JmsUtils.convertJmsAccessException(e); 
        }
    }

    public Spittle retrieveSpittleAlert() {
        return (Spittle) jmsOperations.receiveAndConvert();
    }
</code></pre>

<p>启动消息处理：</p>

<pre><code class="language-JAVA">     public static void main(String[] args) {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;META-INF/spring/messaging.xml&quot;);
        AlertService alertService = context.getBean(AlertService.class);
        while (true) {
            Spittle s = alertService.retrieveSpittleAlert();
            System.out.println(s);
        }
    }
</code></pre>

<p>receive() 和 receiveAndConvert() 的缺点是 他们都是同步的，只有在有消息是才会唤醒，否则一直等待。</p>

<hr/>

<h2 id="toc_9">配置和使用消息监听器</h2>

<p>前面的 receive() 和 receiveAndConvert() 是接收并处理消息的一种方法，但是需要显式的获取消息再处理。</p>

<p>EJB2 规范引入了 消息驱动 Bean（message-driven bean, MDB）,MDB 是可以异步处理消息的 EJB,它将目的地中消息作为事件，并对这些事件进行相应。而与之相反的是，同步消息接受这在消息可用前一直处理堵塞状态。</p>

<p>EJB2 MDB的唯一缺点是它们必须实现 java.ejb.MessageDrivenBean,此外还必须实现一些 EJB 生命周期的回调方法。简而言之，EJB 2 MDB 不是纯 POJO。</p>

<p>EJB 3规范中，MDB 进一步简化， 使其更像 POJO，不在需要实现 MessageDrivenBean，而是实现更通用的 javax.jms.MessageListener接口，并使用 @MessageDriven 注解标注 MDB。</p>

<p>Spring 2.0提供了它自己的消息驱动 bean 来满足接收异步消息的需求，形式与 EJB 3 的 MDB相似。</p>

<p>Spring 提供了以 POJO 的方式处理消息的能力。</p>

<p>第一步，编写处理消息对象的代码，跟普通代码没什么区别，以下代码没有迹象表明它跟 JMS 有关，但是通过配置就可以使用它处理消息。</p>

<pre><code class="language-JAVA">package spittr.alerts;

import spittr.domain.Spittle;

public class SpittleAlertHandler {

    public void handleSpittleAlert(Spittle spittle) {
        System.out.println(spittle.getMessage());
    }

}
</code></pre>

<p>第二步，配置消息监听</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:jms=&quot;http://www.springframework.org/schema/jms&quot;
       xmlns:amq=&quot;http://activemq.apache.org/schema/core&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/jms
        http://www.springframework.org/schema/jms/spring-jms-3.2.xsd
        http://activemq.apache.org/schema/core
        http://activemq.apache.org/schema/core/activemq-core.xsd
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;amq:connectionFactory id=&quot;connectionFactory&quot; brokerURL=&quot;tcp://localhost:61616&quot;/&gt;

    &lt;bean id=&quot;spittleHandler&quot; class=&quot;spittr.alerts.SpittleAlertHandler&quot; /&gt;

    &lt;jms:listener-container&gt;
        &lt;jms:listener destination=&quot;spittle.alert.queue&quot;
                      ref=&quot;spittleHandler&quot;
                      method=&quot;handleSpittleAlert&quot;
        /&gt;
    &lt;/jms:listener-container&gt;

&lt;/beans&gt;
</code></pre>

<p>最后，启动监听应用：</p>

<pre><code class="language-JAVA">package spittr;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public class JmsListenerMain {

    public static void main(String[] args) {
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;META-INF/spring/message_listener.xml&quot;);
    }
}
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-10-02T16:58:29+08:00" itemprop="datePublished">2016/10/2</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Spring.html'>Spring</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14753987093319.html" itemprop="url">
		Spring REST API (2) 客户端</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p><em>——《Spring实战》笔记 第16章</em></p>

<h2 id="toc_0">传统的 HttpClient</h2>

<h2 id="toc_1">RestTemplate</h2>

<pre><code class="language-JAVA">package org.springframework.web.client;

public class RestTemplate extends InterceptingHttpAccessor implements RestOperations {
...
}
</code></pre>

<p>RestTemplate定义了11个独立的操作：</p>

<table>
<thead>
<tr>
<th> 方法</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>delete()</td>
<td>在特定的URL上对资源指定 HTTP DELETE 操作</td>
</tr>
<tr>
<td>exchange()</td>
<td>在URL上执行 HTTP 方法，返回包含对象的 ResponseEntity，这个对象是从相应提中映射得到的</td>
</tr>
<tr>
<td>execute()</td>
<td>在 URL 上执行特定的 HTTP 方法，返回一个从响应体映射得到的对象</td>
</tr>
<tr>
<td>getForEntity()</td>
<td>发送一个 HTTP GET 请求，返回的 ResponseEntity 包含了响应体所映射成的对象</td>
</tr>
<tr>
<td>getForObject()</td>
<td>发送一个 HTTP GET 请求，返回的请求体将映射成一个对象</td>
</tr>
<tr>
<td>headForHeaders()</td>
<td>发送一个 HTTP HEAD 请求，返回包含特定资源 URL 的 HTTP 头</td>
</tr>
<tr>
<td>optionsForAllow()</td>
<td>发送一个 HTTP OPTIONS 请求，返回特定的 URL 的 Allow 头信息</td>
</tr>
<tr>
<td>postForEntity()</td>
<td>POST 数据到一个 URL，返回一个对象的 ResponseEntity，这个对象是从响应体映射得到的</td>
</tr>
<tr>
<td>postForLocation()</td>
<td>POST 数据到一个URL，返回新创建资源的URL</td>
</tr>
<tr>
<td>postForObject()</td>
<td>POST 数据到一个URL，返回根据响应体匹配形成的对象</td>
</tr>
<tr>
<td>put()</td>
<td>PUT 资源到特定的 URL</td>
</tr>
</tbody>
</table>

<p>这些操作都提供了 3 种形式的重载方法：</p>

<ol>
<li>一个使用 java.net.URI 作为 URL 格式，不支持参数化 URL；</li>
<li>一个使用 String 作为URL 格式，并使用 Map 指明 URL 参数；</li>
<li>一个使用 String 作为 URL 格式，并使用可变参数列表指明 URL 参数；</li>
</ol>

<h3 id="toc_2">GET 资源 getForObject、getForEntity</h3>

<p>从 org.springframework.web.client.RestTemplate 类中可以看到有以下获取 GET 资源的方法方法：</p>

<pre><code>&lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;
&lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;
&lt;T&gt; T getForObject(URI url, Class&lt;T&gt; responseType) throws RestClientException;

&lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;
&lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;
&lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(URI url, Class&lt;T&gt; responseType) throws RestClientException;
</code></pre>

<p>可以看出这种 getForObject、getForEntity 方法的3个重载方法，<strong>getForObject 和 getForEntity 方法的区别是：getForObject 直接获取资源，返回的结果就是要获取的对象，丢弃 HttpStatus 和 Headers 信息，而 getForEntity 方法完整的保留了这些信息，这些信息包括返回的对象全部放在一个 ResponseEntity 对象中，使用这个方法可以做更多的事情。</strong>，通过代码<code>public class ResponseEntity&lt;T&gt; extends HttpEntity&lt;T&gt;</code>可以看到 ResponseEntity 其实是 HttpEntity 的子类，通过<code>getHttpStatus()</code>可以获取 HTTP 返回码, 通过<code>getHeaders()</code> 方法可以获取返回头，通过 <code>getBody()</code>可以获取返回对象。</p>

<h4 id="toc_3">关于返回头信息 HttpHeaders</h4>

<ol>
<li>通过 response.getHeaders()可以获取到 返回头信息对象 HttpHeaders;</li>
<li>HttpHeaders 类提供了2类方法：getXXX()和 getFirstXXX(),XXX代表头信息关键字，前者返回列表，后者返回列表中的第一个；</li>
<li>HttpHeaders包含的信息通过类中枚举值定义就可以看出来：</li>
</ol>

<pre><code>    private static final long serialVersionUID = -8578554704772377436L;

    private static final String ACCEPT = &quot;Accept&quot;;

    private static final String ACCEPT_CHARSET = &quot;Accept-Charset&quot;;

    private static final String ALLOW = &quot;Allow&quot;;

    private static final String CACHE_CONTROL = &quot;Cache-Control&quot;;

    private static final String CONNECTION = &quot;Connection&quot;;

    private static final String CONTENT_DISPOSITION = &quot;Content-Disposition&quot;;

    private static final String CONTENT_LENGTH = &quot;Content-Length&quot;;

    private static final String CONTENT_TYPE = &quot;Content-Type&quot;;

    private static final String DATE = &quot;Date&quot;;

    private static final String ETAG = &quot;ETag&quot;;

    private static final String EXPIRES = &quot;Expires&quot;;

    private static final String IF_MODIFIED_SINCE = &quot;If-Modified-Since&quot;;

    private static final String IF_NONE_MATCH = &quot;If-None-Match&quot;;

    private static final String LAST_MODIFIED = &quot;Last-Modified&quot;;

    private static final String LOCATION = &quot;Location&quot;;

    private static final String ORIGIN = &quot;Origin&quot;;

    private static final String PRAGMA = &quot;Pragma&quot;;

    private static final String UPGRADE = &quot;Upgrade&quot;;
</code></pre>

<h3 id="toc_4">PUT 资源</h3>

<ol>
<li>以 put 方式发送请求；</li>
<li>注意返回值是 void，而不是对象，相当于无法获取服务端相应的相关 Header 信息。</li>
</ol>

<pre><code>    void put(String url, Object request, Object... uriVariables) throws RestClientException;
    void put(String url, Object request, Map&lt;String, ?&gt; uriVariables) throws RestClientException;
    void put(URI url, Object request) throws RestClientException;
</code></pre>

<h3 id="toc_5">DELETE 资源</h3>

<ol>
<li>以 put 方式发送请求；</li>
<li>注意返回值是 void，而不是对象，相当于无法获取服务端相应的相关 Header 信息。</li>
</ol>

<pre><code>    void delete(String url, Object request, Object... uriVariables) throws RestClientException;
    void delete(String url, Object request, Map&lt;String, ?&gt; uriVariables) throws RestClientException;
    void delete(URI url, Object request) throws RestClientException;
</code></pre>

<h3 id="toc_6">POST 资源</h3>

<ol>
<li>post方法跟 get 方法一样，但是比 get 方法多了3个 postForLocation方法；</li>
<li>postForLocation 方法会忽略掉返回的其它信息，只获取返回 Headers的 Location 信息，类型为 URI;</li>
<li>postForLocation 方法对服务端有要求，在 post 资源成功后要往返回的头部设置 Location 信息。</li>
</ol>

<pre><code>&lt;T&gt; T postForObject(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;
&lt;T&gt; T postForObject(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;
&lt;T&gt; T postForObject(URI url, Class&lt;T&gt; responseType) throws RestClientException;

&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;
&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;
&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(URI url, Class&lt;T&gt; responseType) throws RestClientException;

URI postForLocation(String url, Object request, Object... uriVariables) throws RestClientException;
URI postForLocation(String url, Object request, Map&lt;String, ?&gt; uriVariables) throws RestClientException;
URI postForLocation(URI url, Object request) throws RestClientException;
</code></pre>

<h3 id="toc_7">交换资源</h3>

<p>exchange 方法是唯一能够在发送给服务器的请求中设置头信息的方法。</p>

<pre><code class="language-JAVA">&lt;T&gt; ResponseEntity&lt;T&gt; exchange(String url, HttpMethod method, HttpEntity&lt;?&gt; requestEntity,
            Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;
&lt;T&gt; ResponseEntity&lt;T&gt; exchange(String url, HttpMethod method, HttpEntity&lt;?&gt; requestEntity,
            Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;
&lt;T&gt; ResponseEntity&lt;T&gt; exchange(URI url, HttpMethod method, HttpEntity&lt;?&gt; requestEntity,
            Class&lt;T&gt; responseType) throws RestClientException;
&lt;T&gt; ResponseEntity&lt;T&gt; exchange(String url,HttpMethod method, HttpEntity&lt;?&gt; requestEntity,
            ParameterizedTypeReference&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;
&lt;T&gt; ResponseEntity&lt;T&gt; exchange(String url, HttpMethod method, HttpEntity&lt;?&gt; requestEntity,
            ParameterizedTypeReference&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;
&lt;T&gt; ResponseEntity&lt;T&gt; exchange(URI url, HttpMethod method, HttpEntity&lt;?&gt; requestEntity,
            ParameterizedTypeReference&lt;T&gt; responseType) throws RestClientException;
</code></pre>

<h3 id="toc_8">注意事项</h3>

<ol>
<li>发送请求的 Content-Type以及发送对象的形式怎么设置的？</li>
</ol>

<h2 id="toc_9">使用用例：</h2>

<pre><code class="language-JAVA">package spittr.web;

import org.springframework.http.HttpEntity;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;
import spittr.model.Spitter;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.HashMap;
import java.util.Map;

/**
 * Created by tianhao on 16/10/2.
 */
public class SpringHttpClient {

    public Spitter getSpitterForObject1(Long id) {
        RestTemplate rest = new RestTemplate();
        return rest.getForObject(&quot;http://localhost:8080/getSpitter/{id}&quot;,Spitter.class,id);
    }

    public Spitter getSpitterForObject2(Long id) {
        RestTemplate rest = new RestTemplate();
        Map map = new HashMap&lt;&gt;();
        map.put(&quot;id&quot;, id);
        return rest.getForObject(&quot;http://localhost:8080/getSpitter/{id}&quot;,
                Spitter.class,
                map);
    }

    public Spitter getSpitterForObject3(Long id) {
        try {
            RestTemplate rest = new RestTemplate();
            URI uri = new URI(&quot;http://localhost:8080/getSpitter/&quot;+ id);
            return rest.getForObject(uri,Spitter.class);
        } catch (URISyntaxException e) {
            e.printStackTrace();
        }
        return null;
    }

    public Spitter getSpitterForEntity1(Long id) {
        RestTemplate rest = new RestTemplate();
        ResponseEntity&lt;Spitter&gt; response = rest.getForEntity(&quot;http://localhost:8080/getSpitter/{id}&quot;,Spitter.class,id);
        if (response.getStatusCode() == HttpStatus.NOT_MODIFIED){
            throw new NotModifedException();
        }
        return response.getBody();
    }

    public Spitter getSpitterForEntity2(Long id) {
        RestTemplate rest = new RestTemplate();
        Map map = new HashMap&lt;&gt;();
        map.put(&quot;id&quot;, id);
        ResponseEntity&lt;Spitter&gt; response= rest.getForEntity(&quot;http://localhost:8080/getSpitter/{id}&quot;,
                Spitter.class,
                map);
        return response.getBody();
    }

    public Spitter getSpitterForEntity3(Long id) {
        try {
            RestTemplate rest = new RestTemplate();
            URI uri = new URI(&quot;http://localhost:8080/getSpitter/&quot;+ id);
            ResponseEntity&lt;Spitter&gt; response = rest.getForEntity(uri,Spitter.class);
            return response.getBody();
        } catch (URISyntaxException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void putSpitter1(){
        RestTemplate rest = new RestTemplate();
        rest.put(&quot;http://localhost:8080/putSpitter/{id}&quot;, new Spitter(), 1);
    }

    public void putSpitter2(){
        RestTemplate rest = new RestTemplate();
        Map m = new HashMap();
        m.put(&quot;id&quot;, 2);
        rest.put(&quot;http://localhost:8080/putSpitter/{id}&quot;, new Spitter(), m);
    }

    public void putSpitter3(){
        RestTemplate rest = new RestTemplate();
        rest.put(URI.create(&quot;http://localhost:8080/putSpitter/&quot;+3), new Spitter());
    }

    public Spitter exchangeGetSpitter1(){
        RestTemplate rest = new RestTemplate();
        ResponseEntity&lt;Spitter&gt; response = rest.exchange(&quot;http://localhost:8080/getSpitter/{id}&quot;, HttpMethod.GET,null,Spitter.class,1);
        return response.getBody();
    }

    public Spitter exchangePostSpitter(){
        RestTemplate rest = new RestTemplate();
        MultiValueMap&lt;String,String&gt; headers = new LinkedMultiValueMap&lt;&gt;();
        headers.add(&quot;Accept&quot;, &quot;application/json&quot;);
        headers.add(&quot;Content-Type&quot;, &quot;application/json&quot;);
        HttpEntity&lt;Object&gt; requestEntity = new HttpEntity&lt;Object&gt;(new Spitter(), headers);
        ResponseEntity&lt;Spitter&gt; response = rest.exchange(&quot;http://localhost:8080/consumesJsonOrXmlSpitter&quot;, HttpMethod.POST,requestEntity,Spitter.class);
        return response.getBody();
    }

    public static void main(String[] args) {
        SpringHttpClient client = new SpringHttpClient();
        System.out.println(&quot;==== put ====&quot;);
        client.putSpitter1();
        client.putSpitter2();
        client.putSpitter3();
        System.out.println(&quot;==== getSpitterForObjectX ====&quot;);
        Spitter s = client.getSpitterForObject1(1L);
        System.out.println(s);
        s = client.getSpitterForObject2(2L);
        System.out.println(s);
        s = client.getSpitterForObject3(3L);
        System.out.println(s);
        System.out.println(&quot;==== getSpitterForEntityX ====&quot;);
        s = client.getSpitterForEntity1(1L);
        System.out.println(s);
        s = client.getSpitterForEntity2(2L);
        System.out.println(s);
        s = client.getSpitterForEntity3(3L);
        System.out.println(s);
        System.out.println(&quot;==== exchange ====&quot;);
        s = client.exchangeGetSpitter1();
        System.out.println(s);
        s = client.exchangePostSpitter();
        System.out.println(s);
        return;
    }
}
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-09-27T17:27:03+08:00" itemprop="datePublished">2016/9/27</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Spring.html'>Spring</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14749684233883.html" itemprop="url">
		Spring REST API (1) 服务端</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p><em>——《Spring实战》笔记 第16章</em></p>

<h2 id="toc_0">用 @RestController 替代 @Controller + @ResponseBody</h2>

<p>如果一个类所有的接口都不是返回视图的，都是返回数据的，用@RestController 替代 @Controller，可以省去类中大量的  @ResponseBody 注解。</p>

<h2 id="toc_1">强大的 @RequestMapping 注解</h2>

<h3 id="toc_2">1. value 指定接口地址</h3>

<p>value指定接口地址，可用在 Controller类和 Controller类的public方法中，类和方法有层级关系，即最终地址是 “类的value/方法的value”， 如果类上面没有指定value，最终地址是“/方法的value”。</p>

<p>常用示例：</p>

<pre><code class="language-JAVA">@RequestMapping(value = &quot;spitter&quot;)
@RequestMapping(value = &quot;spitter/{id}&quot;)   // 使用id占位符

/*
 * 使用多个占位符，且参数d使用{c}占位符
 * http://localhost:8080/spitter/1/2/3
 */
@RequestMapping(value = &quot;spitter/{a}/{b}/{c}&quot;)
public Map spitter(@PathVariable(&quot;a&quot;) String a, 
                       @PathVariable(&quot;b&quot;) String b, 
                       @PathVariable(&quot;c&quot;) String d) {
    Map&lt;String,String&gt; m = new HashMap();
    m.put(&quot;a&quot;, a);
    m.put(&quot;b&quot;, b);
    m.put(&quot;c&quot;, d);
    return m;
}
</code></pre>

<p>使用占位符时，要使用 <code>@PathVariable(value=&quot;id&quot;)</code>修饰方法中的某个参数，如果@PathVariable没有指定value, Spring 会根据参数名称匹配占位符，但是还是设置比较安全，笔者曾用相同的代码和配置，遇到在Mac下可以匹配但是Linux下不匹配的情况，导致了在Linux下接口不可用错误。</p>

<h3 id="toc_3">2. method 指定接受的Request Method（对应 HTTP Request Method ）</h3>

<p>常用示例：</p>

<pre><code>// 接受所有method的请求
@RequestMapping(value = &quot;getSpitter&quot;)  
or
// 只接受get的请求
@RequestMapping(value = &quot;getSpitter&quot;, method = RequestMethod.GET) 
or
// 只接受post的请求
@RequestMapping(value = &quot;getSpitter&quot;, method = RequestMethod.POST) 
or
// 只接受get和post的请求
@RequestMapping(value = &quot;getSpitter&quot;, method = {RequestMethod.GET, RequestMethod.POST})
</code></pre>

<ol>
<li>不指定method时，默认接受所有类型的请求；</li>
<li>在一个RequestMapping中可以指定一个或多个method类型，指定之后的接口（方法）只接受指定类型（范围）的请求；</li>
<li>对于相同的value, 可以用一个方法处理所有method类型的请求， 也可以拆成多个方法分别处理部分类型的method请求，Spring会将相应的method的请求指派到对应的方法处理，但是要注意，多个方法的method集合不能有交集，否则，程序初始化时不会发现，在收到请求后Spring才会抛出异常<code>HTTP Status 500 - Request processing failed; nested exception is java.lang.IllegalStateException: Ambiguous handler methods mapped for HTTP path ...</code>。</li>
<li>Spring会指定符合请求method类型的方法处理请求，如果没有符合条件的会报404错误，而且是由Spring框架抛出异常，不会流转到接口方法中。</li>
</ol>

<h3 id="toc_4">3. produces 指定返回形式（对应HTTP Accept）</h3>

<p>常用示例:</p>

<pre><code>// 不指定，根据其它条件决定返回形式
@RequestMapping(value = &quot;xmlSpitter&quot;) 
// 指定xml
@RequestMapping(value = &quot;xmlSpitter&quot;, produces = &quot;application/xml&quot;)
// 指定json
@RequestMapping(value = &quot;jsonSpitter&quot;, produces = &quot;application/json&quot;)
// 指定3个，优先第一个
@RequestMapping(value = &quot;multiSpitter&quot;, produces = {&quot;application/json&quot;, &quot;application/xml&quot;,  &quot;text/plain&quot;})
</code></pre>

<p>Http 请求的Accept 由A/B 两部分组成。A有：application、text、image。B有很多种，常用的有：json，xml，html，plain，有时还带版本号。由A和B可以产生很多组合，但是我们程序最终返回形式一般由B部分决定。</p>

<p>produces是为了指定接口返回数据的形式而存在的，有以下规则：</p>

<ol>
<li>不指定produces时，Spring使用自有的一套规则决定将接口对应的方法返回的对象序列化成对应的形式，决定因素有接口后缀、请求的Accept类型等等。

<ol>
<li>接口后缀为json时返回json；</li>
<li>接口后缀.xml返回xml形式;</li>
<li>Accept的B是xml时序列化成XML形式</li>
<li>当Accept的B是json时序列化成json形式。</li>
</ol></li>
<li>使用produces可以指定一个或多个类型，当指定produces时，指定接口只会返回指定范围的形式，当指定多个形式时，指定顺序会影响优先级，其它影响因素相同的情况下，优先返回第一个；</li>
<li>当Spring决定返回某种形式时，在classpath中必须有指定类型的序列化库，开发者可以为Spring指定序列化库，如果没有指定，Spring会根据框架中的指定的常用序列化库查找classpath的库，使用找到的库序列化，如果没找到就抛出异常。PS:JDK6开始自带了XML系列化库JAXB，不需要增加依赖包。</li>
<li>当决定返回xml形式时，返回的对象的类要有@XmlRootElement/@XmlElement之类的注解，使用注解时至少要有@XmlRootElement注解，另外，如果类中有@XmlRootElement注解，会将返回xml形式的优先级提高（经试验，如果没有指定produces，而类中有这个注解，会默认返回xml形式,否则返回json）。</li>
</ol>

<h3 id="toc_5">4. consumes + @RequestBody 指定request body类型 (对应HTTP Content-Type)</h3>

<p>常用示例：</p>

<pre><code>// 一个方法处理多个Content-Type请求
@RequestMapping(value = &quot;consumesJsonOrXmlSpitter&quot;,
            consumes = {&quot;application/json&quot;, &quot;application/xml&quot;},
            method = RequestMethod.POST)
public Spitter consumesJsonOrXmlSpitter(@RequestBody Spitter spitter) {
    return spitter;
}

or

// 分成多个方法，分别处理部分Content-Type请求, 但是不能有重叠（交集）
@RequestMapping(value = &quot;consumesJsonSpitter&quot;, consumes = {&quot;application/json&quot;})
public Spitter consumesJsonSpitter(@RequestBody Spitter spitter) {
    return spitter;
}

@RequestMapping(value = &quot;consumesXmlSpitter&quot;, consumes = {&quot;application/xml&quot;})
public Spitter consumesXmlSpitter(@RequestBody Spitter spitter) {
    return spitter;
}
</code></pre>

<p>这个例子可以通过设置请求的 Accept 和 Content-Type 将一种类型转化成另一种类型</p>

<ol>
<li>默认情况下接口只接受也只能解析 text类型的请求参数，类似于<code>a=x&amp;b=y&amp;...</code>；</li>
<li>使用 consumes 可以设置接口只接受一个或多个类型的Content-Type，并且要使用@RequestBody注解某个参数，使得请求参数被反系列化到指定参数中；</li>
<li>要注意，<strong>实际请求有多余的参数，即有些参数在接受参数的类中找不到对应的属性，会抛出异常400 - Bad Request 错误</strong>， 而如果不用consumes + @RequestBody组合，<strong>而用默认的参数绑定，会忽略掉多余的参数，不会抛出异常，程序会处理请求</strong>；</li>
<li>跟 method 一样，相同的@RequestMapping value 可以由一个方法处理所有类型的Content-Type,也可以拆分成多个方法分别处理部分的Content-Type, 但是拆分的方法Content-Type集合不能有交集。</li>
</ol>

<h2 id="toc_6">用 @ExceptionHandler + @ResponseStatus 统一异常处理</h2>

<p><strong>首先定义异常信息类</strong></p>

<pre><code class="language-JAVA">public class ErrorInfo {

    private int code;
    private String message;

    public ErrorInfo(int code, String message){
        this.code = code;
        this.message = message;
    }

    public int getCode() {
        return code;
    }

    public void setCode(int code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
</code></pre>

<p><strong>自定义异常类</strong></p>

<pre><code class="language-JAVA">public class SpittleNotFoundException extends RuntimeException {
    private long spittleId;

    public SpittleNotFoundException(long spittleId) {
        this.spittleId = spittleId;
    }

    public long getSpittleId() {
        return spittleId;
    }
}
</code></pre>

<p><strong>在控制类中使用统一异常处理</strong></p>

<pre><code class="language-JAVA">    // 为本控制类添加异常处理方法
    @ExceptionHandler(SpittleNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)  // 设置返回码，默认是200
    @ResponseBody // 如果要返回视图，则不要增加这行注解
    public ErrorInfo spittleNotFound(SpittleNotFoundException e) {
        long spittleid = e.getSpittleId();
        return new ErrorInfo(4, &quot;Spitter [&quot; + spittleid + &quot;] not found!&quot;);
    }

    @RequestMapping(&quot;mode2/{id}&quot;)
    @ResponseBody
    public Spittle findById2(@PathVariable(&quot;id&quot;) long id) {
        if (id &gt; 1) {
            throw new SpittleNotFoundException(id); // 抛出异常,由异常处理方法处理
        }
        return spitterService.getSpittle(id);
    }
</code></pre>

<h2 id="toc_7">使用 ResponseEntity 处理异常、设置返回码和设置返回headers</h2>

<ol>
<li>ResponseEntity可以在返回对象时设置返回码；</li>
<li>使用ResponseEntity 默认是返回数据而不是试图，可以省去 @ResponseBody 注解，加了注解也没问题；</li>
<li>该方法相对 @ExceptionHandler + @ResponseStatus 的方法没有优势，反而在方法的返回类型中增加了ResponseEntity&lt;?或类名&gt;，一般不使用这种方法处理异常； </li>
<li>在新增资源时，为了更好的跟客户端交流，返回码可设置为HttpStatus.CREATED(201)，这个可以通过 @ResponseStatus 注解做到，但是如果要设置返回 headers，需要用 ResponseEntity才能做到，这才是 ResponseEntity 不可替代的地方。</li>
</ol>

<p><strong>处理异常示例</strong></p>

<pre><code class="language-JAVA">    // 为本控制类添加异常处理方法
    @ExceptionHandler(SpittleNotFoundException.class)
    public ResponseEntity&lt;ErrorInfo&gt; spittleNotFound(SpittleNotFoundException e) {
        long spittleid = e.getSpittleId();
        ErrorInfo error = new ErrorInfo(4, &quot;Spitter [&quot; + spittleid + &quot;] not found!&quot;);
        return new ResponseEntity&lt;ErrorInfo&gt;(error, HttpStatus.NOT_FOUND);
    }


    @RequestMapping(&quot;mode2/{id}&quot;)
    public ResponseEntity&lt;?&gt; findById2(@PathVariable(&quot;id&quot;) long id) {
        if (id &gt; 1) {
            throw new SpittleNotFoundException(id); // 抛出异常,由异常处理方法
        }
        return new ResponseEntity&lt;Spittle&gt;(spitterService.getSpittle(id), HttpStatus.OK);
    }
</code></pre>

<p><strong>设置返回的headers</strong><br/>
在新增资源时，为了更好的跟客户端交流，返回码可设置为HttpStatus.CREATED(201)，这个可以通过 @ResponseStatus 注解做到，但是如果要设置返回 headers，需要用 ResponseEntity才能做到</p>

<pre><code class="language-JAVA">    @RequestMapping(value = &quot;save&quot;, consumes = &quot;application/json&quot;)
    public ResponseEntity&lt;Spittle&gt; save(@RequestBody Spittle spittle, UriComponentsBuilder ucb) {
        spittle = spitterService.saveSpittle(spittle);
        HttpHeaders headers = new HttpHeaders();
        URI locationUri =
                ucb.path(&quot;/spittles/&quot;)
                .path(String.valueOf(spittle.getId()))
                .build()
                .toUri();
        headers.setLocation(locationUri);

        return new ResponseEntity&lt;Spittle&gt;(spittle,headers, HttpStatus.CREATED);
    }
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-09-25T20:54:13+08:00" itemprop="datePublished">2016/9/25</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Spring.html'>Spring</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14748080531208.html" itemprop="url">
		Spring使用远程服务(2) —— 使用Hessian/Burlap/HttpInvoker</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p><em>——《Spring实战》笔记 第15章</em></p>

<p>这3者都是基于HTTP服务的RPC，其中Hessian和Burlap都是由caucho提供的，HttpInvoker是Spring提供的，他们各自的特点：<br/>
1. Hessian，使用二进制消息进行客户端和服务端交互，可以一直到非Java的语言中，可读性差，节省宽带，使用私有序列化机制，复杂对象不一定行。<br/>
2. Burlap是基于XML的远程条用技术，可以移植到能够解析XML的语言上，可读性强，耗宽带，使用私有序列化机制，复杂对象不一定行。<br/>
3. HttpInvoker，由Spring提供的，使用JAVA对象序列化机制，客户端和服务端都必须是Spring。</p>

<p>Spring下的 Hessian、Burlap、HttpInvoker的使用方式跟RMI差不多，最红要的使用区别是RMI不是MVC，不需要要配置MVC，而其他3个是基于MVC的，要将服务配置进MVC中。</p>

<p>下面可以看到 Hessian、Burlap、HttpInvoker的使用方法除了类名不同意外，几乎完全一致。</p>

<h2 id="toc_0">前提</h2>

<ol>
<li>Hessian、Burlap、HttpInvoker是基于HTTP的远程调用服务， 所以要放在SpringMVC下面；</li>
<li>开放的接口返回的对象要能序列化。</li>
</ol>

<p>坑：经测试，前2种方式的服务都不是很稳定，没有改过任何代码，有时候从客户端能获取到数据，有时候不行，然后重新编译几次又能获取到数据，服务端的代码没什么逻辑直接返回一个对象。</p>

<h2 id="toc_1">1.启用Hessian/Burlap/HttpInvoker服务</h2>

<p>SpringMVC 的HTTP服务有多种配置方式， 通过web.xml + SpringMvc.xml配置 或者 Java代码配置。这里使用Java代码配置。</p>

<p>跟其他的MVC配置类似， 增加了部分配置， 主要是为了让MVC框架能够识别 *.service 的url请求并指派给指定类处理。</p>

<p><strong>DataConfig类</strong><br/>
略</p>

<p><strong>RootConfig类</strong><br/>
略</p>

<p><strong>AbstractAnnotationConfigDispatcherServletInitializer类</strong><br/>
注意最后一个方法<code>getServletMappings</code>增加了<code>*.service</code></p>

<pre><code class="language-JAVA">package spittr.config;

import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

import spittr.web.WebConfig;

public class SpitterWebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
  
  @Override
  protected Class&lt;?&gt;[] getRootConfigClasses() {
    return new Class&lt;?&gt;[] { RootConfig.class };
  }

  @Override
  protected Class&lt;?&gt;[] getServletConfigClasses() {
    return new Class&lt;?&gt;[] { WebConfig.class };
  }

  @Override
  protected String[] getServletMappings() {
    return new String[] { &quot;/&quot;, &quot;*.service&quot; };
  }

}
</code></pre>

<p><strong>WebMvcConfigurerAdapter类</strong></p>

<p>这里新增了4个Beans: <strong>HessianServiceExporter</strong> 、<strong>BurlapServiceExporter</strong> 、<strong>HttpInvokerServiceExporter</strong> 和 <strong>HandlerMapping</strong>, 前3个Bean分别开启Hessian、Burlap和HttpInvoker服务，都是将SpitterService封装成HTTP服务发布出去，发布的地址与MVC容器的地址一致，最后HandlerMapping将这3个封装好的绑定到相应的URL地址，提供给外部访问。<br/>
特别注意HandlerMapping 中设置了<code>mapping.setOrder(0);</code>， 这是因为一般的MVC项目都会在 <code>configureDefaultServletHandling</code>方法中设置<code>configurer.enable();</code>，它的效果是除了Controller中指定的URL路径，其它URL都作为静态资源的URL， 而我们新增的HandlerMappingURL优先级低于静态资源，最终变成404错误， 所以要把新增的HandlerMapping优先级提高到比静态资源高，这里强制设成0，其实应该有更优化的值。</p>

<pre><code class="language-JAVA">package spittr.web;

import ...此处略过一堆package

@Configuration
@EnableWebMvc
@ComponentScan(&quot;spittr.web&quot;)
public class WebConfig extends WebMvcConfigurerAdapter {

    ...此处略过一堆其它MVC配置。
    
   @Bean
    public SpitterService spitterService(){
        return new SpitterServiceImpl();
    }

    @Bean
    public HessianServiceExporter hessianExportedSpitterService(SpitterService spitterService){
        HessianServiceExporter exporter = new HessianServiceExporter();
        exporter.setService(spitterService);
        exporter.setServiceInterface(SpitterService.class);
        return exporter;
    }

    @Bean
    public BurlapServiceExporter burlapExportedSpitterService(SpitterService spitterService){
        BurlapServiceExporter exporter = new BurlapServiceExporter();
        exporter.setService(spitterService);
        exporter.setServiceInterface(SpitterService.class);
        return exporter;
    }

     @Bean
    public HttpInvokerServiceExporter httpExportedSpitterService(SpitterService spitterService){
        HttpInvokerServiceExporter exporter = new HttpInvokerServiceExporter();
        exporter.setService(spitterService);
        exporter.setServiceInterface(SpitterService.class);
        return exporter;
    }

    @Bean
    public HandlerMapping hessianMapping() {
        SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
        Properties mappings = new Properties();
        mappings.setProperty(&quot;/hessian/spitter.service&quot;, &quot;hessianExportedSpitterService&quot;);
        mappings.setProperty(&quot;/burlap/spitter.service&quot;, &quot;burlapExportedSpitterService&quot;);
        mappings.setProperty(&quot;/httpinvoker/spitter.service&quot;, &quot;httpExportedSpitterService&quot;);
        mapping.setMappings(mappings);
        mapping.setOrder(0);
        return mapping;
    }

    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }

}

</code></pre>

<h2 id="toc_2">2.客户端代码</h2>

<h3 id="toc_3">Hessian客户端</h3>

<p><strong>配置类</strong></p>

<pre><code class="language-JAVA">package spittr.client;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.remoting.caucho.HessianProxyFactoryBean;
import spittr.service.SpitterService;

/**
 * Created by tianhao on 16/9/25.
 */
@Configuration
public class HessianClientConfig {

    @Bean
    public HessianProxyFactoryBean spitterService(){
        HessianProxyFactoryBean proxy = new HessianProxyFactoryBean();
        proxy.setServiceUrl(&quot;http://localhost:8080/hessian/spitter.service&quot;);
        proxy.setServiceInterface(SpitterService.class);
        return proxy;
    }

}
</code></pre>

<p><strong>测试Hessian服务</strong><br/>
注意：这里的ctx.getBean(&quot;spitterService&quot;)中的<code>spitterService</code>对应的是HessianClientConfig类的<code>spitterService()</code>方法的名称，如果两边名称不一致会获取不到Bean。</p>

<pre><code class="language-JAVA">package spittr.client;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import spittr.model.Spitter;
import spittr.service.SpitterService;

/**
 * Created by tianhao on 16/9/25.
 */
public class HessionClientMain {

    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(HessianClientConfig.class);
        SpitterService service = (SpitterService) ctx.getBean(&quot;spitterService&quot;);
        Spitter spitter = service.getSpitter(0);
        if (spitter != null) {
            System.out.println(&quot;返回结果:&quot; + spitter.toString());
        } else {
            System.out.println(&quot;没有获取到数据.&quot;);
        }
    }
}
</code></pre>

<h3 id="toc_4">Burlap客户端</h3>

<p><strong>配置类</strong></p>

<pre><code class="language-JAVA">package spittr.client;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.remoting.caucho.BurlapProxyFactoryBean;
import spittr.service.SpitterService;

/**
 * Created by tianhao on 16/9/25.
 */
@Configuration
public class BurlapClientConfig {

    @Bean
    public BurlapProxyFactoryBean spitterService(){
        BurlapProxyFactoryBean proxy = new BurlapProxyFactoryBean();
        proxy.setServiceUrl(&quot;http://localhost:8080/burlap/spitter.service&quot;);
        proxy.setServiceInterface(SpitterService.class);
        return proxy;
    }

}
</code></pre>

<p><strong>测试Burlap服务</strong><br/>
注意：这里的ctx.getBean(&quot;spitterService&quot;)中的<code>spitterService</code>对应的是BurlapClientConfig类的<code>spitterService()</code>方法的名称，如果两边名称不一致会获取不到Bean。</p>

<pre><code class="language-JAVA">package spittr.client;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import spittr.model.Spitter;
import spittr.service.SpitterService;

/**
 * Created by tianhao on 16/9/25.
 */
public class BurlapClientMain {

    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(BurlapClientConfig.class);
        SpitterService service = (SpitterService) ctx.getBean(&quot;spitterService&quot;);

        Spitter spitter = service.getSpitter(0);
        if (spitter != null) {
            System.out.println(&quot;返回结果:&quot; + spitter.toString());
        } else {
            System.out.println(&quot;没有获取到数据.&quot;);
        }
    }
}

</code></pre>

<h3 id="toc_5">HttpInvoker客户端</h3>

<p><strong>配置类</strong></p>

<pre><code class="language-JAVA">package spittr.client;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.remoting.caucho.BurlapProxyFactoryBean;
import spittr.service.SpitterService;

/**
 * Created by tianhao on 16/9/25.
 */
@Configuration
public class HttpInvokerClientConfig {

    @Bean
    public BurlapProxyFactoryBean spitterService(){
        BurlapProxyFactoryBean proxy = new BurlapProxyFactoryBean();
        proxy.setServiceUrl(&quot;http://localhost:8080/httpinvoker/spitter.service&quot;);
        proxy.setServiceInterface(SpitterService.class);
        return proxy;
    }

}
</code></pre>

<p><strong>测试HttpInvoker服务</strong></p>

<pre><code class="language-JAVA">package spittr.client;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import spittr.model.Spitter;
import spittr.service.SpitterService;

/**
 * Created by tianhao on 16/9/25.
 */
public class HttpInvokerClientMain {

    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(BurlapClientConfig.class);
        SpitterService service = (SpitterService) ctx.getBean(&quot;spitterService&quot;);

        Spitter spitter = service.getSpitter(0);
        if (spitter != null) {
            System.out.println(&quot;返回结果:&quot; + spitter.toString());
        } else {
            System.out.println(&quot;没有获取到数据.&quot;);
        }
    }
}
</code></pre>

<h2 id="toc_6">3.踩坑总结：</h2>

<ol>
<li>服务端的HandlerMapping需要设置顺序；</li>
<li>客户端Bean名称要与配置类的方法名称一致；</li>
<li>测试不通过时先把缓存清理干净（包括编译的文件）再测试</li>
<li>依赖包只要：<code>compile group: &#39;com.caucho&#39;, name: &#39;hessian&#39;, version: &#39;4.0.38&#39;</code>, 包含Hessian和Burlap，不要再导入burlap的包，否则冲突</li>
</ol>

<h2 id="toc_7">4.附上gradle配置</h2>

<p><strong>build.gradle</strong></p>

<pre><code class="language-Gradle">apply plugin: &#39;eclipse&#39;
apply plugin: &#39;war&#39;
apply plugin: &#39;eclipse-wtp&#39;

dependencies {
    compile &quot;org.springframework:spring-webmvc:4.0.7.RELEASE&quot;
    compile &quot;org.springframework:spring-jdbc:4.0.7.RELEASE&quot;
    compile &quot;com.h2database:h2:1.4.182&quot;
    compile &quot;org.hibernate:hibernate-validator:5.0.1.Final&quot;
    compile &quot;org.apache.commons:commons-lang3:3.1&quot;
    compile &quot;org.thymeleaf:thymeleaf-spring4:2.1.3.RELEASE&quot;

    providedCompile &quot;javax.servlet:javax.servlet-api:3.1.0&quot;

    testCompile &quot;junit:junit-dep:4.11&quot;
    testCompile &quot;org.springframework:spring-test:4.0.7.RELEASE&quot;
    testCompile &quot;org.mockito:mockito-core:1.9.5&quot;
    testCompile &quot;org.hamcrest:hamcrest-library:1.3&quot;

    compile group: &#39;com.caucho&#39;, name: &#39;hessian&#39;, version: &#39;4.0.38&#39;
//    compile group: &#39;com.caucho&#39;, name: &#39;burlap&#39;, version: &#39;2.1.12&#39;

}

repositories {
    maven { url &#39;http://maven.springframework.org/release&#39; }
    maven { url &#39;http://maven.springframework.org/milestone&#39; }
    maven { url &#39;http://maven.springframework.org/snapshot&#39; }
    maven { url &#39;http://download.java.net/maven/2&#39; }
    mavenCentral()
}

task wrapper(type: Wrapper) {
    gradleVersion = &#39;1.8&#39;
}

war {
    baseName = &#39;spittr&#39;
}

eclipse {
    wtp {
        component {
            contextPath = &#39;spittr&#39;
        }
    }
}
</code></pre>

<p><strong>settings.gradle</strong></p>

<pre><code>rootProject.name = &#39;HessianBurlap&#39;
</code></pre>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="all_1.html">Prev</a>  
	 <a class="next" href="all_3.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    
<script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

</body>
</html>