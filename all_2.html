<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <title>
        
        #(coding X)
        
    </title>

    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="atom.xml" rel="alternate" title="#(coding X)" type="application/atom+xml">

    <link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script src="asset/javascripts/jquery.min.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>

    <!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
    <!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
    <style type="text/css">
        /* latin */
        @font-face {
            font-family: 'Nunito';
            font-style: normal;
            font-weight: 300;
            src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
            unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
        }
        /* latin */
        @font-face {
            font-family: 'Nunito';
            font-style: normal;
            font-weight: 400;
            src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
            unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
        }
        /* latin */
        @font-face {
            font-family: 'Nunito';
            font-style: normal;
            font-weight: 700;
            src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
            unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
        }
    </style>

    <style type="text/css">
        .container .left-col{ opacity: 1;}
        #pagenavi a{ font-size: 1.3em;}
        #pagenavi .next:before{ top: 3px;}
        #pagenavi .prev:before{ top: 3px;}
        .container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
        .container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
        #header .subtitle {
            line-height: 1.2em;
            padding-top: 8px;
        }
        article pre{ background: none; border: none; padding: 0;}
        article .entry-content{text-align: left;}
        .share-comment{ padding: 25px 0px; clear: both;}
        hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
    </style>

</head>

<body>
<div class="container">
    <div class="left-col">
        <div class="intrude-less">
            <header id="header" class="inner">
                
                <div class="profilepic">
                    <img src="asset/icon.png" style="width:160px;">
                </div>
                

                <h1><a href="index.html">#(coding X)</a></h1>
                <p class="subtitle">写代码，折腾各种好玩的东西！</p>
                <nav id="main-nav">
                    <ul class="main">
                        
                        <li id=""><a target="_self" href="index.html">Home</a></li>
                        
                        <li id=""><a target="_self" href="archives.html">Archives</a></li>
                        
                    </ul>
                </nav>

                <nav id="sub-nav">
                    <div class="social">

                        
                        
                        
                        
                        
                        
                        
                        <a target="_blank" class="weibo" href="




http://weibo.com/liemi" title="weibo">Weibo</a>
                        <a target="_blank" class="twitter" target="_blank" href="https://twitter.com/tianhaox_com" title="Twitter">Twitter</a>
                        <a target="_blank" class="github" target="_blank" href="https://github.com/tianhao" title="GitHub">GitHub</a>
                        

                        <a class="rss" href="atom.xml" title="RSS">RSS</a>

                    </div>
                </nav>
                <br>
                <div id="site-categories" class="side-item ">
                    <div class="side-header">
                        <h2>Categories</h2>
                    </div>
                    <div class="side-content">
                        <p class="cat-list">
                            
                            <a href="Life.html"><strong>Life</strong></a>
                            
                            <a href="Spring.html"><strong>Spring</strong></a>
                            
                            <a href="Spring%20Boot.html"><strong>Spring Boot</strong></a>
                            
                        </p>
                    </div>
                </div>
								<br>
                <div id="site-categories" class="side-item">
                    <div class="side-header">
                        <h2>Recent Posts</h2>
                    </div>
                    <div class="side-content">
                        <ul class="posts-list">
                            
                            
                            <li class="post">
                                <a href="14787505123542.html">SpringBoot 开发工具</a>
                            </li>
                            
                            
                            
                            <li class="post">
                                <a href="14786773151130.html">Spring Boot 发布</a>
                            </li>
                            
                            
                            
                            <li class="post">
                                <a href="14786335106268.html">Spring Boot 深入Actuator</a>
                            </li>
                            
                            
                            
                            <li class="post">
                                <a href="14785948397032.html">Spring Boot 自定义配置</a>
                            </li>
                            
                            
                            
                            <li class="post">
                                <a href="14785852868633.html">Spring Boot 开发第一个应用程序</a>
                            </li>
                            
                            
                            
                            <li class="post">
                                <a href="14785139214429.html">Spring Boot 入门：安装和构建</a>
                            </li>
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            
                        </ul>
                    </div>
                </div>
            </header>
        </div> <!-- intrude-less -->
    </div> <!-- left-col -->

    <div class="mid-col">
        <div class="mid-col-container">
 <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-10-02T16:58:29+08:00" itemprop="datePublished">2016/10/2</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Spring.html'>Spring</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14753987093319.html" itemprop="url">
		Spring REST API (2) 客户端</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p><em>——《Spring实战》笔记 第16章</em></p>

<h2 id="toc_0">传统的 HttpClient</h2>

<h2 id="toc_1">RestTemplate</h2>

<pre><code class="language-JAVA">package org.springframework.web.client;

public class RestTemplate extends InterceptingHttpAccessor implements RestOperations {
...
}
</code></pre>

<p>RestTemplate定义了11个独立的操作：</p>

<table>
<thead>
<tr>
<th> 方法</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>delete()</td>
<td>在特定的URL上对资源指定 HTTP DELETE 操作</td>
</tr>
<tr>
<td>exchange()</td>
<td>在URL上执行 HTTP 方法，返回包含对象的 ResponseEntity，这个对象是从相应提中映射得到的</td>
</tr>
<tr>
<td>execute()</td>
<td>在 URL 上执行特定的 HTTP 方法，返回一个从响应体映射得到的对象</td>
</tr>
<tr>
<td>getForEntity()</td>
<td>发送一个 HTTP GET 请求，返回的 ResponseEntity 包含了响应体所映射成的对象</td>
</tr>
<tr>
<td>getForObject()</td>
<td>发送一个 HTTP GET 请求，返回的请求体将映射成一个对象</td>
</tr>
<tr>
<td>headForHeaders()</td>
<td>发送一个 HTTP HEAD 请求，返回包含特定资源 URL 的 HTTP 头</td>
</tr>
<tr>
<td>optionsForAllow()</td>
<td>发送一个 HTTP OPTIONS 请求，返回特定的 URL 的 Allow 头信息</td>
</tr>
<tr>
<td>postForEntity()</td>
<td>POST 数据到一个 URL，返回一个对象的 ResponseEntity，这个对象是从响应体映射得到的</td>
</tr>
<tr>
<td>postForLocation()</td>
<td>POST 数据到一个URL，返回新创建资源的URL</td>
</tr>
<tr>
<td>postForObject()</td>
<td>POST 数据到一个URL，返回根据响应体匹配形成的对象</td>
</tr>
<tr>
<td>put()</td>
<td>PUT 资源到特定的 URL</td>
</tr>
</tbody>
</table>

<p>这些操作都提供了 3 种形式的重载方法：</p>

<ol>
<li>一个使用 java.net.URI 作为 URL 格式，不支持参数化 URL；</li>
<li>一个使用 String 作为URL 格式，并使用 Map 指明 URL 参数；</li>
<li>一个使用 String 作为 URL 格式，并使用可变参数列表指明 URL 参数；</li>
</ol>

<h3 id="toc_2">GET 资源 getForObject、getForEntity</h3>

<p>从 org.springframework.web.client.RestTemplate 类中可以看到有以下获取 GET 资源的方法方法：</p>

<pre><code>&lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;
&lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;
&lt;T&gt; T getForObject(URI url, Class&lt;T&gt; responseType) throws RestClientException;

&lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;
&lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;
&lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(URI url, Class&lt;T&gt; responseType) throws RestClientException;
</code></pre>

<p>可以看出这种 getForObject、getForEntity 方法的3个重载方法，<strong>getForObject 和 getForEntity 方法的区别是：getForObject 直接获取资源，返回的结果就是要获取的对象，丢弃 HttpStatus 和 Headers 信息，而 getForEntity 方法完整的保留了这些信息，这些信息包括返回的对象全部放在一个 ResponseEntity 对象中，使用这个方法可以做更多的事情。</strong>，通过代码<code>public class ResponseEntity&lt;T&gt; extends HttpEntity&lt;T&gt;</code>可以看到 ResponseEntity 其实是 HttpEntity 的子类，通过<code>getHttpStatus()</code>可以获取 HTTP 返回码, 通过<code>getHeaders()</code> 方法可以获取返回头，通过 <code>getBody()</code>可以获取返回对象。</p>

<h4 id="toc_3">关于返回头信息 HttpHeaders</h4>

<ol>
<li>通过 response.getHeaders()可以获取到 返回头信息对象 HttpHeaders;</li>
<li>HttpHeaders 类提供了2类方法：getXXX()和 getFirstXXX(),XXX代表头信息关键字，前者返回列表，后者返回列表中的第一个；</li>
<li>HttpHeaders包含的信息通过类中枚举值定义就可以看出来：</li>
</ol>

<pre><code>    private static final long serialVersionUID = -8578554704772377436L;

    private static final String ACCEPT = &quot;Accept&quot;;

    private static final String ACCEPT_CHARSET = &quot;Accept-Charset&quot;;

    private static final String ALLOW = &quot;Allow&quot;;

    private static final String CACHE_CONTROL = &quot;Cache-Control&quot;;

    private static final String CONNECTION = &quot;Connection&quot;;

    private static final String CONTENT_DISPOSITION = &quot;Content-Disposition&quot;;

    private static final String CONTENT_LENGTH = &quot;Content-Length&quot;;

    private static final String CONTENT_TYPE = &quot;Content-Type&quot;;

    private static final String DATE = &quot;Date&quot;;

    private static final String ETAG = &quot;ETag&quot;;

    private static final String EXPIRES = &quot;Expires&quot;;

    private static final String IF_MODIFIED_SINCE = &quot;If-Modified-Since&quot;;

    private static final String IF_NONE_MATCH = &quot;If-None-Match&quot;;

    private static final String LAST_MODIFIED = &quot;Last-Modified&quot;;

    private static final String LOCATION = &quot;Location&quot;;

    private static final String ORIGIN = &quot;Origin&quot;;

    private static final String PRAGMA = &quot;Pragma&quot;;

    private static final String UPGRADE = &quot;Upgrade&quot;;
</code></pre>

<h3 id="toc_4">PUT 资源</h3>

<ol>
<li>以 put 方式发送请求；</li>
<li>注意返回值是 void，而不是对象，相当于无法获取服务端相应的相关 Header 信息。</li>
</ol>

<pre><code>    void put(String url, Object request, Object... uriVariables) throws RestClientException;
    void put(String url, Object request, Map&lt;String, ?&gt; uriVariables) throws RestClientException;
    void put(URI url, Object request) throws RestClientException;
</code></pre>

<h3 id="toc_5">DELETE 资源</h3>

<ol>
<li>以 put 方式发送请求；</li>
<li>注意返回值是 void，而不是对象，相当于无法获取服务端相应的相关 Header 信息。</li>
</ol>

<pre><code>    void delete(String url, Object request, Object... uriVariables) throws RestClientException;
    void delete(String url, Object request, Map&lt;String, ?&gt; uriVariables) throws RestClientException;
    void delete(URI url, Object request) throws RestClientException;
</code></pre>

<h3 id="toc_6">POST 资源</h3>

<ol>
<li>post方法跟 get 方法一样，但是比 get 方法多了3个 postForLocation方法；</li>
<li>postForLocation 方法会忽略掉返回的其它信息，只获取返回 Headers的 Location 信息，类型为 URI;</li>
<li>postForLocation 方法对服务端有要求，在 post 资源成功后要往返回的头部设置 Location 信息。</li>
</ol>

<pre><code>&lt;T&gt; T postForObject(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;
&lt;T&gt; T postForObject(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;
&lt;T&gt; T postForObject(URI url, Class&lt;T&gt; responseType) throws RestClientException;

&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;
&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;
&lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(URI url, Class&lt;T&gt; responseType) throws RestClientException;

URI postForLocation(String url, Object request, Object... uriVariables) throws RestClientException;
URI postForLocation(String url, Object request, Map&lt;String, ?&gt; uriVariables) throws RestClientException;
URI postForLocation(URI url, Object request) throws RestClientException;
</code></pre>

<h3 id="toc_7">交换资源</h3>

<p>exchange 方法是唯一能够在发送给服务器的请求中设置头信息的方法。</p>

<pre><code class="language-JAVA">&lt;T&gt; ResponseEntity&lt;T&gt; exchange(String url, HttpMethod method, HttpEntity&lt;?&gt; requestEntity,
            Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;
&lt;T&gt; ResponseEntity&lt;T&gt; exchange(String url, HttpMethod method, HttpEntity&lt;?&gt; requestEntity,
            Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;
&lt;T&gt; ResponseEntity&lt;T&gt; exchange(URI url, HttpMethod method, HttpEntity&lt;?&gt; requestEntity,
            Class&lt;T&gt; responseType) throws RestClientException;
&lt;T&gt; ResponseEntity&lt;T&gt; exchange(String url,HttpMethod method, HttpEntity&lt;?&gt; requestEntity,
            ParameterizedTypeReference&lt;T&gt; responseType, Object... uriVariables) throws RestClientException;
&lt;T&gt; ResponseEntity&lt;T&gt; exchange(String url, HttpMethod method, HttpEntity&lt;?&gt; requestEntity,
            ParameterizedTypeReference&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException;
&lt;T&gt; ResponseEntity&lt;T&gt; exchange(URI url, HttpMethod method, HttpEntity&lt;?&gt; requestEntity,
            ParameterizedTypeReference&lt;T&gt; responseType) throws RestClientException;
</code></pre>

<h3 id="toc_8">注意事项</h3>

<ol>
<li>发送请求的 Content-Type以及发送对象的形式怎么设置的？</li>
</ol>

<h2 id="toc_9">使用用例：</h2>

<pre><code class="language-JAVA">package spittr.web;

import org.springframework.http.HttpEntity;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;
import spittr.model.Spitter;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.HashMap;
import java.util.Map;

/**
 * Created by tianhao on 16/10/2.
 */
public class SpringHttpClient {

    public Spitter getSpitterForObject1(Long id) {
        RestTemplate rest = new RestTemplate();
        return rest.getForObject(&quot;http://localhost:8080/getSpitter/{id}&quot;,Spitter.class,id);
    }

    public Spitter getSpitterForObject2(Long id) {
        RestTemplate rest = new RestTemplate();
        Map map = new HashMap&lt;&gt;();
        map.put(&quot;id&quot;, id);
        return rest.getForObject(&quot;http://localhost:8080/getSpitter/{id}&quot;,
                Spitter.class,
                map);
    }

    public Spitter getSpitterForObject3(Long id) {
        try {
            RestTemplate rest = new RestTemplate();
            URI uri = new URI(&quot;http://localhost:8080/getSpitter/&quot;+ id);
            return rest.getForObject(uri,Spitter.class);
        } catch (URISyntaxException e) {
            e.printStackTrace();
        }
        return null;
    }

    public Spitter getSpitterForEntity1(Long id) {
        RestTemplate rest = new RestTemplate();
        ResponseEntity&lt;Spitter&gt; response = rest.getForEntity(&quot;http://localhost:8080/getSpitter/{id}&quot;,Spitter.class,id);
        if (response.getStatusCode() == HttpStatus.NOT_MODIFIED){
            throw new NotModifedException();
        }
        return response.getBody();
    }

    public Spitter getSpitterForEntity2(Long id) {
        RestTemplate rest = new RestTemplate();
        Map map = new HashMap&lt;&gt;();
        map.put(&quot;id&quot;, id);
        ResponseEntity&lt;Spitter&gt; response= rest.getForEntity(&quot;http://localhost:8080/getSpitter/{id}&quot;,
                Spitter.class,
                map);
        return response.getBody();
    }

    public Spitter getSpitterForEntity3(Long id) {
        try {
            RestTemplate rest = new RestTemplate();
            URI uri = new URI(&quot;http://localhost:8080/getSpitter/&quot;+ id);
            ResponseEntity&lt;Spitter&gt; response = rest.getForEntity(uri,Spitter.class);
            return response.getBody();
        } catch (URISyntaxException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void putSpitter1(){
        RestTemplate rest = new RestTemplate();
        rest.put(&quot;http://localhost:8080/putSpitter/{id}&quot;, new Spitter(), 1);
    }

    public void putSpitter2(){
        RestTemplate rest = new RestTemplate();
        Map m = new HashMap();
        m.put(&quot;id&quot;, 2);
        rest.put(&quot;http://localhost:8080/putSpitter/{id}&quot;, new Spitter(), m);
    }

    public void putSpitter3(){
        RestTemplate rest = new RestTemplate();
        rest.put(URI.create(&quot;http://localhost:8080/putSpitter/&quot;+3), new Spitter());
    }

    public Spitter exchangeGetSpitter1(){
        RestTemplate rest = new RestTemplate();
        ResponseEntity&lt;Spitter&gt; response = rest.exchange(&quot;http://localhost:8080/getSpitter/{id}&quot;, HttpMethod.GET,null,Spitter.class,1);
        return response.getBody();
    }

    public Spitter exchangePostSpitter(){
        RestTemplate rest = new RestTemplate();
        MultiValueMap&lt;String,String&gt; headers = new LinkedMultiValueMap&lt;&gt;();
        headers.add(&quot;Accept&quot;, &quot;application/json&quot;);
        headers.add(&quot;Content-Type&quot;, &quot;application/json&quot;);
        HttpEntity&lt;Object&gt; requestEntity = new HttpEntity&lt;Object&gt;(new Spitter(), headers);
        ResponseEntity&lt;Spitter&gt; response = rest.exchange(&quot;http://localhost:8080/consumesJsonOrXmlSpitter&quot;, HttpMethod.POST,requestEntity,Spitter.class);
        return response.getBody();
    }

    public static void main(String[] args) {
        SpringHttpClient client = new SpringHttpClient();
        System.out.println(&quot;==== put ====&quot;);
        client.putSpitter1();
        client.putSpitter2();
        client.putSpitter3();
        System.out.println(&quot;==== getSpitterForObjectX ====&quot;);
        Spitter s = client.getSpitterForObject1(1L);
        System.out.println(s);
        s = client.getSpitterForObject2(2L);
        System.out.println(s);
        s = client.getSpitterForObject3(3L);
        System.out.println(s);
        System.out.println(&quot;==== getSpitterForEntityX ====&quot;);
        s = client.getSpitterForEntity1(1L);
        System.out.println(s);
        s = client.getSpitterForEntity2(2L);
        System.out.println(s);
        s = client.getSpitterForEntity3(3L);
        System.out.println(s);
        System.out.println(&quot;==== exchange ====&quot;);
        s = client.exchangeGetSpitter1();
        System.out.println(s);
        s = client.exchangePostSpitter();
        System.out.println(s);
        return;
    }
}
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-09-27T17:27:03+08:00" itemprop="datePublished">2016/9/27</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Spring.html'>Spring</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14749684233883.html" itemprop="url">
		Spring REST API (1) 服务端</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p><em>——《Spring实战》笔记 第16章</em></p>

<h2 id="toc_0">用 @RestController 替代 @Controller + @ResponseBody</h2>

<p>如果一个类所有的接口都不是返回视图的，都是返回数据的，用@RestController 替代 @Controller，可以省去类中大量的  @ResponseBody 注解。</p>

<h2 id="toc_1">强大的 @RequestMapping 注解</h2>

<h3 id="toc_2">1. value 指定接口地址</h3>

<p>value指定接口地址，可用在 Controller类和 Controller类的public方法中，类和方法有层级关系，即最终地址是 “类的value/方法的value”， 如果类上面没有指定value，最终地址是“/方法的value”。</p>

<p>常用示例：</p>

<pre><code class="language-JAVA">@RequestMapping(value = &quot;spitter&quot;)
@RequestMapping(value = &quot;spitter/{id}&quot;)   // 使用id占位符

/*
 * 使用多个占位符，且参数d使用{c}占位符
 * http://localhost:8080/spitter/1/2/3
 */
@RequestMapping(value = &quot;spitter/{a}/{b}/{c}&quot;)
public Map spitter(@PathVariable(&quot;a&quot;) String a, 
                       @PathVariable(&quot;b&quot;) String b, 
                       @PathVariable(&quot;c&quot;) String d) {
    Map&lt;String,String&gt; m = new HashMap();
    m.put(&quot;a&quot;, a);
    m.put(&quot;b&quot;, b);
    m.put(&quot;c&quot;, d);
    return m;
}
</code></pre>

<p>使用占位符时，要使用 <code>@PathVariable(value=&quot;id&quot;)</code>修饰方法中的某个参数，如果@PathVariable没有指定value, Spring 会根据参数名称匹配占位符，但是还是设置比较安全，笔者曾用相同的代码和配置，遇到在Mac下可以匹配但是Linux下不匹配的情况，导致了在Linux下接口不可用错误。</p>

<h3 id="toc_3">2. method 指定接受的Request Method（对应 HTTP Request Method ）</h3>

<p>常用示例：</p>

<pre><code>// 接受所有method的请求
@RequestMapping(value = &quot;getSpitter&quot;)  
or
// 只接受get的请求
@RequestMapping(value = &quot;getSpitter&quot;, method = RequestMethod.GET) 
or
// 只接受post的请求
@RequestMapping(value = &quot;getSpitter&quot;, method = RequestMethod.POST) 
or
// 只接受get和post的请求
@RequestMapping(value = &quot;getSpitter&quot;, method = {RequestMethod.GET, RequestMethod.POST})
</code></pre>

<ol>
<li>不指定method时，默认接受所有类型的请求；</li>
<li>在一个RequestMapping中可以指定一个或多个method类型，指定之后的接口（方法）只接受指定类型（范围）的请求；</li>
<li>对于相同的value, 可以用一个方法处理所有method类型的请求， 也可以拆成多个方法分别处理部分类型的method请求，Spring会将相应的method的请求指派到对应的方法处理，但是要注意，多个方法的method集合不能有交集，否则，程序初始化时不会发现，在收到请求后Spring才会抛出异常<code>HTTP Status 500 - Request processing failed; nested exception is java.lang.IllegalStateException: Ambiguous handler methods mapped for HTTP path ...</code>。</li>
<li>Spring会指定符合请求method类型的方法处理请求，如果没有符合条件的会报404错误，而且是由Spring框架抛出异常，不会流转到接口方法中。</li>
</ol>

<h3 id="toc_4">3. produces 指定返回形式（对应HTTP Accept）</h3>

<p>常用示例:</p>

<pre><code>// 不指定，根据其它条件决定返回形式
@RequestMapping(value = &quot;xmlSpitter&quot;) 
// 指定xml
@RequestMapping(value = &quot;xmlSpitter&quot;, produces = &quot;application/xml&quot;)
// 指定json
@RequestMapping(value = &quot;jsonSpitter&quot;, produces = &quot;application/json&quot;)
// 指定3个，优先第一个
@RequestMapping(value = &quot;multiSpitter&quot;, produces = {&quot;application/json&quot;, &quot;application/xml&quot;,  &quot;text/plain&quot;})
</code></pre>

<p>Http 请求的Accept 由A/B 两部分组成。A有：application、text、image。B有很多种，常用的有：json，xml，html，plain，有时还带版本号。由A和B可以产生很多组合，但是我们程序最终返回形式一般由B部分决定。</p>

<p>produces是为了指定接口返回数据的形式而存在的，有以下规则：</p>

<ol>
<li>不指定produces时，Spring使用自有的一套规则决定将接口对应的方法返回的对象序列化成对应的形式，决定因素有接口后缀、请求的Accept类型等等。

<ol>
<li>接口后缀为json时返回json；</li>
<li>接口后缀.xml返回xml形式;</li>
<li>Accept的B是xml时序列化成XML形式</li>
<li>当Accept的B是json时序列化成json形式。</li>
</ol></li>
<li>使用produces可以指定一个或多个类型，当指定produces时，指定接口只会返回指定范围的形式，当指定多个形式时，指定顺序会影响优先级，其它影响因素相同的情况下，优先返回第一个；</li>
<li>当Spring决定返回某种形式时，在classpath中必须有指定类型的序列化库，开发者可以为Spring指定序列化库，如果没有指定，Spring会根据框架中的指定的常用序列化库查找classpath的库，使用找到的库序列化，如果没找到就抛出异常。PS:JDK6开始自带了XML系列化库JAXB，不需要增加依赖包。</li>
<li>当决定返回xml形式时，返回的对象的类要有@XmlRootElement/@XmlElement之类的注解，使用注解时至少要有@XmlRootElement注解，另外，如果类中有@XmlRootElement注解，会将返回xml形式的优先级提高（经试验，如果没有指定produces，而类中有这个注解，会默认返回xml形式,否则返回json）。</li>
</ol>

<h3 id="toc_5">4. consumes + @RequestBody 指定request body类型 (对应HTTP Content-Type)</h3>

<p>常用示例：</p>

<pre><code>// 一个方法处理多个Content-Type请求
@RequestMapping(value = &quot;consumesJsonOrXmlSpitter&quot;,
            consumes = {&quot;application/json&quot;, &quot;application/xml&quot;},
            method = RequestMethod.POST)
public Spitter consumesJsonOrXmlSpitter(@RequestBody Spitter spitter) {
    return spitter;
}

or

// 分成多个方法，分别处理部分Content-Type请求, 但是不能有重叠（交集）
@RequestMapping(value = &quot;consumesJsonSpitter&quot;, consumes = {&quot;application/json&quot;})
public Spitter consumesJsonSpitter(@RequestBody Spitter spitter) {
    return spitter;
}

@RequestMapping(value = &quot;consumesXmlSpitter&quot;, consumes = {&quot;application/xml&quot;})
public Spitter consumesXmlSpitter(@RequestBody Spitter spitter) {
    return spitter;
}
</code></pre>

<p>这个例子可以通过设置请求的 Accept 和 Content-Type 将一种类型转化成另一种类型</p>

<ol>
<li>默认情况下接口只接受也只能解析 text类型的请求参数，类似于<code>a=x&amp;b=y&amp;...</code>；</li>
<li>使用 consumes 可以设置接口只接受一个或多个类型的Content-Type，并且要使用@RequestBody注解某个参数，使得请求参数被反系列化到指定参数中；</li>
<li>要注意，<strong>实际请求有多余的参数，即有些参数在接受参数的类中找不到对应的属性，会抛出异常400 - Bad Request 错误</strong>， 而如果不用consumes + @RequestBody组合，<strong>而用默认的参数绑定，会忽略掉多余的参数，不会抛出异常，程序会处理请求</strong>；</li>
<li>跟 method 一样，相同的@RequestMapping value 可以由一个方法处理所有类型的Content-Type,也可以拆分成多个方法分别处理部分的Content-Type, 但是拆分的方法Content-Type集合不能有交集。</li>
</ol>

<h2 id="toc_6">用 @ExceptionHandler + @ResponseStatus 统一异常处理</h2>

<p><strong>首先定义异常信息类</strong></p>

<pre><code class="language-JAVA">public class ErrorInfo {

    private int code;
    private String message;

    public ErrorInfo(int code, String message){
        this.code = code;
        this.message = message;
    }

    public int getCode() {
        return code;
    }

    public void setCode(int code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
</code></pre>

<p><strong>自定义异常类</strong></p>

<pre><code class="language-JAVA">public class SpittleNotFoundException extends RuntimeException {
    private long spittleId;

    public SpittleNotFoundException(long spittleId) {
        this.spittleId = spittleId;
    }

    public long getSpittleId() {
        return spittleId;
    }
}
</code></pre>

<p><strong>在控制类中使用统一异常处理</strong></p>

<pre><code class="language-JAVA">    // 为本控制类添加异常处理方法
    @ExceptionHandler(SpittleNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)  // 设置返回码，默认是200
    @ResponseBody // 如果要返回视图，则不要增加这行注解
    public ErrorInfo spittleNotFound(SpittleNotFoundException e) {
        long spittleid = e.getSpittleId();
        return new ErrorInfo(4, &quot;Spitter [&quot; + spittleid + &quot;] not found!&quot;);
    }

    @RequestMapping(&quot;mode2/{id}&quot;)
    @ResponseBody
    public Spittle findById2(@PathVariable(&quot;id&quot;) long id) {
        if (id &gt; 1) {
            throw new SpittleNotFoundException(id); // 抛出异常,由异常处理方法处理
        }
        return spitterService.getSpittle(id);
    }
</code></pre>

<h2 id="toc_7">使用 ResponseEntity 处理异常、设置返回码和设置返回headers</h2>

<ol>
<li>ResponseEntity可以在返回对象时设置返回码；</li>
<li>使用ResponseEntity 默认是返回数据而不是试图，可以省去 @ResponseBody 注解，加了注解也没问题；</li>
<li>该方法相对 @ExceptionHandler + @ResponseStatus 的方法没有优势，反而在方法的返回类型中增加了ResponseEntity&lt;?或类名&gt;，一般不使用这种方法处理异常； </li>
<li>在新增资源时，为了更好的跟客户端交流，返回码可设置为HttpStatus.CREATED(201)，这个可以通过 @ResponseStatus 注解做到，但是如果要设置返回 headers，需要用 ResponseEntity才能做到，这才是 ResponseEntity 不可替代的地方。</li>
</ol>

<p><strong>处理异常示例</strong></p>

<pre><code class="language-JAVA">    // 为本控制类添加异常处理方法
    @ExceptionHandler(SpittleNotFoundException.class)
    public ResponseEntity&lt;ErrorInfo&gt; spittleNotFound(SpittleNotFoundException e) {
        long spittleid = e.getSpittleId();
        ErrorInfo error = new ErrorInfo(4, &quot;Spitter [&quot; + spittleid + &quot;] not found!&quot;);
        return new ResponseEntity&lt;ErrorInfo&gt;(error, HttpStatus.NOT_FOUND);
    }


    @RequestMapping(&quot;mode2/{id}&quot;)
    public ResponseEntity&lt;?&gt; findById2(@PathVariable(&quot;id&quot;) long id) {
        if (id &gt; 1) {
            throw new SpittleNotFoundException(id); // 抛出异常,由异常处理方法
        }
        return new ResponseEntity&lt;Spittle&gt;(spitterService.getSpittle(id), HttpStatus.OK);
    }
</code></pre>

<p><strong>设置返回的headers</strong><br/>
在新增资源时，为了更好的跟客户端交流，返回码可设置为HttpStatus.CREATED(201)，这个可以通过 @ResponseStatus 注解做到，但是如果要设置返回 headers，需要用 ResponseEntity才能做到</p>

<pre><code class="language-JAVA">    @RequestMapping(value = &quot;save&quot;, consumes = &quot;application/json&quot;)
    public ResponseEntity&lt;Spittle&gt; save(@RequestBody Spittle spittle, UriComponentsBuilder ucb) {
        spittle = spitterService.saveSpittle(spittle);
        HttpHeaders headers = new HttpHeaders();
        URI locationUri =
                ucb.path(&quot;/spittles/&quot;)
                .path(String.valueOf(spittle.getId()))
                .build()
                .toUri();
        headers.setLocation(locationUri);

        return new ResponseEntity&lt;Spittle&gt;(spittle,headers, HttpStatus.CREATED);
    }
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-09-25T20:54:13+08:00" itemprop="datePublished">2016/9/25</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Spring.html'>Spring</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14748080531208.html" itemprop="url">
		Spring使用远程服务(2) —— 使用Hessian/Burlap/HttpInvoker</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p><em>——《Spring实战》笔记 第15章</em></p>

<p>这3者都是基于HTTP服务的RPC，其中Hessian和Burlap都是由caucho提供的，HttpInvoker是Spring提供的，他们各自的特点：<br/>
1. Hessian，使用二进制消息进行客户端和服务端交互，可以一直到非Java的语言中，可读性差，节省宽带，使用私有序列化机制，复杂对象不一定行。<br/>
2. Burlap是基于XML的远程条用技术，可以移植到能够解析XML的语言上，可读性强，耗宽带，使用私有序列化机制，复杂对象不一定行。<br/>
3. HttpInvoker，由Spring提供的，使用JAVA对象序列化机制，客户端和服务端都必须是Spring。</p>

<p>Spring下的 Hessian、Burlap、HttpInvoker的使用方式跟RMI差不多，最红要的使用区别是RMI不是MVC，不需要要配置MVC，而其他3个是基于MVC的，要将服务配置进MVC中。</p>

<p>下面可以看到 Hessian、Burlap、HttpInvoker的使用方法除了类名不同意外，几乎完全一致。</p>

<h2 id="toc_0">前提</h2>

<ol>
<li>Hessian、Burlap、HttpInvoker是基于HTTP的远程调用服务， 所以要放在SpringMVC下面；</li>
<li>开放的接口返回的对象要能序列化。</li>
</ol>

<p>坑：经测试，前2种方式的服务都不是很稳定，没有改过任何代码，有时候从客户端能获取到数据，有时候不行，然后重新编译几次又能获取到数据，服务端的代码没什么逻辑直接返回一个对象。</p>

<h2 id="toc_1">1.启用Hessian/Burlap/HttpInvoker服务</h2>

<p>SpringMVC 的HTTP服务有多种配置方式， 通过web.xml + SpringMvc.xml配置 或者 Java代码配置。这里使用Java代码配置。</p>

<p>跟其他的MVC配置类似， 增加了部分配置， 主要是为了让MVC框架能够识别 *.service 的url请求并指派给指定类处理。</p>

<p><strong>DataConfig类</strong><br/>
略</p>

<p><strong>RootConfig类</strong><br/>
略</p>

<p><strong>AbstractAnnotationConfigDispatcherServletInitializer类</strong><br/>
注意最后一个方法<code>getServletMappings</code>增加了<code>*.service</code></p>

<pre><code class="language-JAVA">package spittr.config;

import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

import spittr.web.WebConfig;

public class SpitterWebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
  
  @Override
  protected Class&lt;?&gt;[] getRootConfigClasses() {
    return new Class&lt;?&gt;[] { RootConfig.class };
  }

  @Override
  protected Class&lt;?&gt;[] getServletConfigClasses() {
    return new Class&lt;?&gt;[] { WebConfig.class };
  }

  @Override
  protected String[] getServletMappings() {
    return new String[] { &quot;/&quot;, &quot;*.service&quot; };
  }

}
</code></pre>

<p><strong>WebMvcConfigurerAdapter类</strong></p>

<p>这里新增了4个Beans: <strong>HessianServiceExporter</strong> 、<strong>BurlapServiceExporter</strong> 、<strong>HttpInvokerServiceExporter</strong> 和 <strong>HandlerMapping</strong>, 前3个Bean分别开启Hessian、Burlap和HttpInvoker服务，都是将SpitterService封装成HTTP服务发布出去，发布的地址与MVC容器的地址一致，最后HandlerMapping将这3个封装好的绑定到相应的URL地址，提供给外部访问。<br/>
特别注意HandlerMapping 中设置了<code>mapping.setOrder(0);</code>， 这是因为一般的MVC项目都会在 <code>configureDefaultServletHandling</code>方法中设置<code>configurer.enable();</code>，它的效果是除了Controller中指定的URL路径，其它URL都作为静态资源的URL， 而我们新增的HandlerMappingURL优先级低于静态资源，最终变成404错误， 所以要把新增的HandlerMapping优先级提高到比静态资源高，这里强制设成0，其实应该有更优化的值。</p>

<pre><code class="language-JAVA">package spittr.web;

import ...此处略过一堆package

@Configuration
@EnableWebMvc
@ComponentScan(&quot;spittr.web&quot;)
public class WebConfig extends WebMvcConfigurerAdapter {

    ...此处略过一堆其它MVC配置。
    
   @Bean
    public SpitterService spitterService(){
        return new SpitterServiceImpl();
    }

    @Bean
    public HessianServiceExporter hessianExportedSpitterService(SpitterService spitterService){
        HessianServiceExporter exporter = new HessianServiceExporter();
        exporter.setService(spitterService);
        exporter.setServiceInterface(SpitterService.class);
        return exporter;
    }

    @Bean
    public BurlapServiceExporter burlapExportedSpitterService(SpitterService spitterService){
        BurlapServiceExporter exporter = new BurlapServiceExporter();
        exporter.setService(spitterService);
        exporter.setServiceInterface(SpitterService.class);
        return exporter;
    }

     @Bean
    public HttpInvokerServiceExporter httpExportedSpitterService(SpitterService spitterService){
        HttpInvokerServiceExporter exporter = new HttpInvokerServiceExporter();
        exporter.setService(spitterService);
        exporter.setServiceInterface(SpitterService.class);
        return exporter;
    }

    @Bean
    public HandlerMapping hessianMapping() {
        SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
        Properties mappings = new Properties();
        mappings.setProperty(&quot;/hessian/spitter.service&quot;, &quot;hessianExportedSpitterService&quot;);
        mappings.setProperty(&quot;/burlap/spitter.service&quot;, &quot;burlapExportedSpitterService&quot;);
        mappings.setProperty(&quot;/httpinvoker/spitter.service&quot;, &quot;httpExportedSpitterService&quot;);
        mapping.setMappings(mappings);
        mapping.setOrder(0);
        return mapping;
    }

    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }

}

</code></pre>

<h2 id="toc_2">2.客户端代码</h2>

<h3 id="toc_3">Hessian客户端</h3>

<p><strong>配置类</strong></p>

<pre><code class="language-JAVA">package spittr.client;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.remoting.caucho.HessianProxyFactoryBean;
import spittr.service.SpitterService;

/**
 * Created by tianhao on 16/9/25.
 */
@Configuration
public class HessianClientConfig {

    @Bean
    public HessianProxyFactoryBean spitterService(){
        HessianProxyFactoryBean proxy = new HessianProxyFactoryBean();
        proxy.setServiceUrl(&quot;http://localhost:8080/hessian/spitter.service&quot;);
        proxy.setServiceInterface(SpitterService.class);
        return proxy;
    }

}
</code></pre>

<p><strong>测试Hessian服务</strong><br/>
注意：这里的ctx.getBean(&quot;spitterService&quot;)中的<code>spitterService</code>对应的是HessianClientConfig类的<code>spitterService()</code>方法的名称，如果两边名称不一致会获取不到Bean。</p>

<pre><code class="language-JAVA">package spittr.client;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import spittr.model.Spitter;
import spittr.service.SpitterService;

/**
 * Created by tianhao on 16/9/25.
 */
public class HessionClientMain {

    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(HessianClientConfig.class);
        SpitterService service = (SpitterService) ctx.getBean(&quot;spitterService&quot;);
        Spitter spitter = service.getSpitter(0);
        if (spitter != null) {
            System.out.println(&quot;返回结果:&quot; + spitter.toString());
        } else {
            System.out.println(&quot;没有获取到数据.&quot;);
        }
    }
}
</code></pre>

<h3 id="toc_4">Burlap客户端</h3>

<p><strong>配置类</strong></p>

<pre><code class="language-JAVA">package spittr.client;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.remoting.caucho.BurlapProxyFactoryBean;
import spittr.service.SpitterService;

/**
 * Created by tianhao on 16/9/25.
 */
@Configuration
public class BurlapClientConfig {

    @Bean
    public BurlapProxyFactoryBean spitterService(){
        BurlapProxyFactoryBean proxy = new BurlapProxyFactoryBean();
        proxy.setServiceUrl(&quot;http://localhost:8080/burlap/spitter.service&quot;);
        proxy.setServiceInterface(SpitterService.class);
        return proxy;
    }

}
</code></pre>

<p><strong>测试Burlap服务</strong><br/>
注意：这里的ctx.getBean(&quot;spitterService&quot;)中的<code>spitterService</code>对应的是BurlapClientConfig类的<code>spitterService()</code>方法的名称，如果两边名称不一致会获取不到Bean。</p>

<pre><code class="language-JAVA">package spittr.client;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import spittr.model.Spitter;
import spittr.service.SpitterService;

/**
 * Created by tianhao on 16/9/25.
 */
public class BurlapClientMain {

    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(BurlapClientConfig.class);
        SpitterService service = (SpitterService) ctx.getBean(&quot;spitterService&quot;);

        Spitter spitter = service.getSpitter(0);
        if (spitter != null) {
            System.out.println(&quot;返回结果:&quot; + spitter.toString());
        } else {
            System.out.println(&quot;没有获取到数据.&quot;);
        }
    }
}

</code></pre>

<h3 id="toc_5">HttpInvoker客户端</h3>

<p><strong>配置类</strong></p>

<pre><code class="language-JAVA">package spittr.client;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.remoting.caucho.BurlapProxyFactoryBean;
import spittr.service.SpitterService;

/**
 * Created by tianhao on 16/9/25.
 */
@Configuration
public class HttpInvokerClientConfig {

    @Bean
    public BurlapProxyFactoryBean spitterService(){
        BurlapProxyFactoryBean proxy = new BurlapProxyFactoryBean();
        proxy.setServiceUrl(&quot;http://localhost:8080/httpinvoker/spitter.service&quot;);
        proxy.setServiceInterface(SpitterService.class);
        return proxy;
    }

}
</code></pre>

<p><strong>测试HttpInvoker服务</strong></p>

<pre><code class="language-JAVA">package spittr.client;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import spittr.model.Spitter;
import spittr.service.SpitterService;

/**
 * Created by tianhao on 16/9/25.
 */
public class HttpInvokerClientMain {

    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(BurlapClientConfig.class);
        SpitterService service = (SpitterService) ctx.getBean(&quot;spitterService&quot;);

        Spitter spitter = service.getSpitter(0);
        if (spitter != null) {
            System.out.println(&quot;返回结果:&quot; + spitter.toString());
        } else {
            System.out.println(&quot;没有获取到数据.&quot;);
        }
    }
}
</code></pre>

<h2 id="toc_6">3.踩坑总结：</h2>

<ol>
<li>服务端的HandlerMapping需要设置顺序；</li>
<li>客户端Bean名称要与配置类的方法名称一致；</li>
<li>测试不通过时先把缓存清理干净（包括编译的文件）再测试</li>
<li>依赖包只要：<code>compile group: &#39;com.caucho&#39;, name: &#39;hessian&#39;, version: &#39;4.0.38&#39;</code>, 包含Hessian和Burlap，不要再导入burlap的包，否则冲突</li>
</ol>

<h2 id="toc_7">4.附上gradle配置</h2>

<p><strong>build.gradle</strong></p>

<pre><code class="language-Gradle">apply plugin: &#39;eclipse&#39;
apply plugin: &#39;war&#39;
apply plugin: &#39;eclipse-wtp&#39;

dependencies {
    compile &quot;org.springframework:spring-webmvc:4.0.7.RELEASE&quot;
    compile &quot;org.springframework:spring-jdbc:4.0.7.RELEASE&quot;
    compile &quot;com.h2database:h2:1.4.182&quot;
    compile &quot;org.hibernate:hibernate-validator:5.0.1.Final&quot;
    compile &quot;org.apache.commons:commons-lang3:3.1&quot;
    compile &quot;org.thymeleaf:thymeleaf-spring4:2.1.3.RELEASE&quot;

    providedCompile &quot;javax.servlet:javax.servlet-api:3.1.0&quot;

    testCompile &quot;junit:junit-dep:4.11&quot;
    testCompile &quot;org.springframework:spring-test:4.0.7.RELEASE&quot;
    testCompile &quot;org.mockito:mockito-core:1.9.5&quot;
    testCompile &quot;org.hamcrest:hamcrest-library:1.3&quot;

    compile group: &#39;com.caucho&#39;, name: &#39;hessian&#39;, version: &#39;4.0.38&#39;
//    compile group: &#39;com.caucho&#39;, name: &#39;burlap&#39;, version: &#39;2.1.12&#39;

}

repositories {
    maven { url &#39;http://maven.springframework.org/release&#39; }
    maven { url &#39;http://maven.springframework.org/milestone&#39; }
    maven { url &#39;http://maven.springframework.org/snapshot&#39; }
    maven { url &#39;http://download.java.net/maven/2&#39; }
    mavenCentral()
}

task wrapper(type: Wrapper) {
    gradleVersion = &#39;1.8&#39;
}

war {
    baseName = &#39;spittr&#39;
}

eclipse {
    wtp {
        component {
            contextPath = &#39;spittr&#39;
        }
    }
}
</code></pre>

<p><strong>settings.gradle</strong></p>

<pre><code>rootProject.name = &#39;HessianBurlap&#39;
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2016-09-25T18:02:01+08:00" itemprop="datePublished">2016/9/25</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Spring.html'>Spring</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14747977219341.html" itemprop="url">
		Spring使用远程服务(1) —— 使用RMI</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p><em>——《Spring实战》笔记 第15章</em></p>

<p>RMI可以将本地接口封装成可远程调用的服务，客户端可以像调用本地接口一样调用封装后的服务。</p>

<h2 id="toc_0">前提条件</h2>

<ol>
<li>客户端和服务端都必须是Java；</li>
<li>RMI封装的接口返回的对象必须可序列化，否则抛异常，例如：<code>public class Spitter implements Serializable {...}</code> ；</li>
<li>由于需要序列化，所以客户端和服务端要保证版本完全一致；</li>
</ol>

<h2 id="toc_1">1. 解决发布RMI服务时不能指定registryHost的坑（多网卡不能指定网卡，比如内网网卡）</h2>

<p>参见： <a href="http://stackoverflow.com/questions/10094416/rmiserviceexporter-not-working-does-not-connect-to-rmi-localhost-at-port-1099">http://stackoverflow.com/questions/10094416/rmiserviceexporter-not-working-does-not-connect-to-rmi-localhost-at-port-1099</a></p>

<pre><code class="language-Java">import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.RMIClientSocketFactory;
import java.rmi.server.RMIServerSocketFactory;

public class MyRmiServiceExporter extends RmiServiceExporter {

    protected Registry getRegistry(String registryHost, int registryPort,
                                   RMIClientSocketFactory clientSocketFactory, RMIServerSocketFactory serverSocketFactory)
            throws RemoteException
    {

        if (registryHost != null) {
            // Host explictly specified: only lookup possible.
            if (logger.isInfoEnabled()) {
                logger.info(&quot;Looking for RMI registry at port &#39;&quot; + registryPort + &quot;&#39; of host [&quot; + registryHost + &quot;]&quot;);
            }
            try {
                Registry reg = LocateRegistry.getRegistry(registryHost, registryPort, clientSocketFactory);
                testRegistry(reg);
                return reg;
            } catch (RemoteException ex) {
                logger.debug(&quot;RMI registry access threw exception&quot;, ex);
                logger.warn(&quot;Could not detect RMI registry - creating new one&quot;);
                // Assume no registry found -&gt; create new one.
                LocateRegistry.createRegistry(registryPort);
                Registry reg = LocateRegistry.getRegistry(registryHost, registryPort, clientSocketFactory);
                testRegistry(reg);
                return reg;
            }
        } else {
            return getRegistry(registryPort, clientSocketFactory, serverSocketFactory);
        }
    }
}
</code></pre>

<h2 id="toc_2">2.定义服务接口</h2>

<pre><code class="language-Java">public interface SpitterService {
    List&lt;Spittle&gt; getRecentSpittles(int count);
    void saveSpittle(Spittle spittle);
    void saveSpitter(Spitter spitter);
    Spitter getSpitter(long id);
    void startFollowing(Spitter follower, Spitter followee);
    List&lt;Spittle&gt; getSpittlesForSpitter(Spitter spitter);
    List&lt;Spittle&gt; getSpittlesForSpitter(String username);
    Spitter getSpitter(String username);
    Spittle getSpittleById(long id);
    void deleteSpittle(long id);
    List&lt;Spitter&gt; getAllSpitters();
}
</code></pre>

<h2 id="toc_3">3.发布服务 （XML方式）</h2>

<p><strong>XML配置：</strong></p>

<pre><code class="language-XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;!-- 注入要发布的RMI服务类 --&gt;
    &lt;bean id=&quot;spitterService&quot; class=&quot;service.SpitterServiceImpl&quot;&gt;&lt;/bean&gt;

    &lt;bean class=&quot;config.MyRmiServiceExporter&quot;&gt;
        &lt;!-- RMI服务名称,可自定义服务名称 --&gt;
        &lt;property name=&quot;serviceName&quot; value=&quot;SpitterService&quot; /&gt;
        &lt;!-- 导出实体 --&gt;
        &lt;property name=&quot;service&quot; ref=&quot;spitterService&quot; /&gt;
        &lt;!-- 导出接口 --&gt;
        &lt;property name=&quot;serviceInterface&quot; value=&quot;service.SpitterService&quot; /&gt;
        &lt;!-- 只有使用MyRmiServiceExporter类是才有用, 使用默认类无效 --&gt;
        &lt;property name=&quot;registryHost&quot; value=&quot;localhost&quot;/&gt;
        &lt;!-- spring默认使用1099端口 --&gt;
        &lt;property name=&quot;registryPort&quot; value=&quot;1199&quot; /&gt;

        &lt;property name=&quot;alwaysCreateRegistry&quot; value=&quot;true&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p><strong>启动RMI服务:</strong></p>

<pre><code class="language-JAVA">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * Created by tianhao on 16/9/25.
 */
public class ServerMainWithXml {
    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;server.xml&quot;);
        System.out.println(&quot;已成功发布RMI服务类&quot;);
    }
}
</code></pre>

<h2 id="toc_4">4.客户端调用RMI服务  (XML方式)</h2>

<p><strong>XML配置：</strong></p>

<pre><code class="language-XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;

    &lt;bean id=&quot;spitterService&quot; class=&quot;org.springframework.remoting.rmi.RmiProxyFactoryBean&quot;&gt;
        &lt;property name=&quot;serviceUrl&quot; value=&quot;rmi://localhost:1199/SpitterService&quot; /&gt;
        &lt;property name=&quot;serviceInterface&quot; value=&quot;service.SpitterService&quot; /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p><strong>启动客户端：</strong></p>

<pre><code class="language-JAVA">
import model.Spitter;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import service.SpitterService;

/**
 * Created by tianhao on 16/9/25.
 */
public class ClientMainWithXml {

    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;client.xml&quot;);
        System.out.println(&quot;加载Spring容器,并初始化RMI客户端&quot;);
        SpitterService spitterService = (SpitterService) ctx.getBean(&quot;spitterService&quot;);
        Spitter spitter = spitterService.getSpitter(1);
        System.out.println(&quot;返回结果:&quot; + spitter.toString());
    }
}
</code></pre>

<h2 id="toc_5">5. 发布服务 （JavaConfig方式）</h2>

<p><strong>配置类：</strong></p>

<pre><code class="language-JAVA">package config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import service.SpitterService;
import service.SpitterServiceImpl;

/**
 * Created by tianhao on 16/9/25.
 */
@Configuration
public class RMIServerConfig {

    @Bean
    public SpitterService spitterService(){
        return new SpitterServiceImpl();
    }

    @Bean
    public MyRmiServiceExporter rmiExporter(SpitterService spitterService){
        MyRmiServiceExporter rmiExporter = new MyRmiServiceExporter();
        rmiExporter.setService(spitterService);
        rmiExporter.setServiceName(&quot;SpitterService&quot;);
        rmiExporter.setRegistryHost(&quot;127.0.0.1&quot;);
        rmiExporter.setRegistryPort(1199);
        rmiExporter.setServiceInterface(SpitterService.class);
        return rmiExporter;
    }

}
</code></pre>

<p><strong>启动RMI服务：</strong></p>

<pre><code class="language-JAVA">import config.RMIServerConfig;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

/**
 * Created by tianhao on 16/9/25.
 */
public class ServerMainWithJavaConfig {

    public static void main(String[] args) {
        ApplicationContext ctx =
                new AnnotationConfigApplicationContext(RMIServerConfig.class);
        System.out.println(&quot;已成功发布RMI服务类&quot;);
    }
}
</code></pre>

<h2 id="toc_6">6.客户端调用RMI服务  (JavaConfig方式)</h2>

<p><strong>配置类：</strong></p>

<pre><code class="language-JAVA">package config;

import org.springframework.context.annotation.Bean;
import org.springframework.remoting.rmi.RmiProxyFactoryBean;
import service.SpitterService;

/**
 * Created by tianhao on 16/9/25.
 */
public class RMIClientConfig {

    @Bean
    public RmiProxyFactoryBean spitterService() {
        RmiProxyFactoryBean rmiProxy = new RmiProxyFactoryBean();
        rmiProxy.setServiceUrl(&quot;rmi://localhost:1199/SpitterService&quot;);
        rmiProxy.setServiceInterface(SpitterService.class);
        return rmiProxy;
    }
}
</code></pre>

<p><strong>调用RMI服务：</strong></p>

<pre><code class="language-JAVA">import config.RMIClientConfig;
import model.Spitter;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import service.SpitterService;

/**
 * Created by tianhao on 16/9/25.
 */
public class ClientMainWithJavaConfig {

    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(RMIClientConfig.class);
        System.out.println(&quot;加载Spring容器,并初始化RMI客户端&quot;);
        SpitterService spitterService = (SpitterService) ctx.getBean(&quot;spitterService&quot;);
        Spitter spitter = spitterService.getSpitter(1);
        System.out.println(&quot;返回结果:&quot; + spitter.toString());
    }
}
</code></pre>

<h2 id="toc_7">7.踩坑总结</h2>

<ol>
<li>如果要指定网卡，即设置registryHost参数，需使用1中的解决办法，否则异常；</li>
<li>接口返回的对象要实现 Serializable，虽然仅仅是<code>implements Serializable</code>一下。</li>
</ol>

<h2 id="toc_8">8.附上项目Gradle配置</h2>

<p><strong>build.gradle</strong></p>

<pre><code class="language-Gradle">apply plugin: &#39;eclipse&#39;
apply plugin: &#39;war&#39;
apply plugin: &#39;eclipse-wtp&#39;

dependencies {
    compile &quot;org.springframework:spring-webmvc:4.3.1.RELEASE&quot;
    compile &quot;org.springframework:spring-jdbc:4.3.1.RELEASE&quot;
    compile &quot;org.apache.commons:commons-lang3:3.1&quot;

    testCompile &quot;junit:junit-dep:4.11&quot;
    testCompile &quot;org.springframework:spring-test:4.3.1.RELEASE&quot;
    testCompile &quot;org.mockito:mockito-core:1.9.5&quot;
    testCompile &quot;org.hamcrest:hamcrest-library:1.3&quot;
}

repositories {
    maven { url &#39;http://maven.springframework.org/release&#39; }
    maven { url &#39;http://maven.springframework.org/milestone&#39; }
    maven { url &#39;http://maven.springframework.org/snapshot&#39; }
    maven { url &#39;http://download.java.net/maven/2&#39; }
    mavenCentral()
}

task wrapper(type: Wrapper) {
    gradleVersion = &#39;1.8&#39;
}

war {
    baseName = &#39;service&#39;
}

eclipse {
    wtp {
        component {
            contextPath = &#39;service&#39;
        }
    }
}
</code></pre>

<p><strong>settings.gradle</strong></p>

<pre><code>rootProject.name = &#39;RMI&#39;
</code></pre>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="all_1.html">Prev</a>  
	 <a class="next" href="all_3.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    
<script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

</body>
</html>